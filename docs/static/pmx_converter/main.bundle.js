(()=>{"use strict";var e,t,n,r,o,i,s,a={3036:(e,t,n)=>{n.d(t,{V:()=>r});class r{static AdditionalUV1Kind="additionalUv1";static AdditionalUV2Kind="additionalUv2";static AdditionalUV3Kind="additionalUv3";static AdditionalUV4Kind="additionalUv4";static MatricesSdefCKind="matricesSdefC";static MatricesSdefRW0Kind="matricesSdefRW0";static MatricesSdefRW1Kind="matricesSdefRW1";static MatricesSdefR0Kind="matricesSdefR0";static MatricesSdefR1Kind="matricesSdefR1";static EdgeScaleKind="edgeScale"}},426:(e,t,n)=>{n.d(t,{ZL:()=>g,rw:()=>r});var r,o=n(8506),i=n(9526),s=n(2277),a=n(6041),l=n(9259),d=n(6552),h=n(3036),c=function(e,t,n,r){var o,i=arguments.length,s=i<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(s=(i<3?o(s):i>3?o(t,n,s):o(t,n))||s);return i>3&&s&&Object.defineProperty(t,n,s),s};class u extends i.M{SPHERE_TEXTURE=!1;SPHERE_TEXTURE_BLEND_MODE_MULTIPLY=!1;SPHERE_TEXTURE_BLEND_MODE_ADD=!1;TOON_TEXTURE=!1;IGNORE_DIFFUSE_WHEN_TOON_TEXTURE_DISABLED=!1;APPLY_AMBIENT_COLOR_TO_DIFFUSE=!1;CLAMP_ALPHA=!1;TEXTURE_COLOR=!1;SPHERE_TEXTURE_COLOR=!1;TOON_TEXTURE_COLOR=!1;SDEF=!1}!function(e){e[e.Multiply=1]="Multiply",e[e.Add=2]="Add",e[e.SubTexture=3]="SubTexture"}(r||(r={}));class g extends s.y{_sphereTexture=null;_sphereTextureBlendMode=r.Add;_toonTexture=null;_ignoreDiffuseWhenToonTextureIsNull=!1;textureMultiplicativeColor=new a.ov(1,1,1,1);textureAdditiveColor=new a.ov(0,0,0,0);sphereTextureMultiplicativeColor=new a.ov(1,1,1,1);sphereTextureAdditiveColor=new a.ov(0,0,0,0);toonTextureMultiplicativeColor=new a.ov(1,1,1,1);toonTextureAdditiveColor=new a.ov(0,0,0,0);_applyAmbientColorToDiffuse=!0;_clampAlpha=!0;_useTextureColor=!1;_useSphereTextureColor=!1;_useToonTextureColor=!1;_isEnabled=!1;get isEnabled(){return this._isEnabled}set isEnabled(e){this._isEnabled!==e&&(this._isEnabled=e,this.markAllDefinesAsDirty(),this._enable(e))}get sphereTexture(){return this._sphereTexture}set sphereTexture(e){this._sphereTexture!==e&&(this._sphereTexture=e,this._markAllSubMeshesAsTexturesDirty())}get sphereTextureBlendMode(){return this._sphereTextureBlendMode}set sphereTextureBlendMode(e){this._sphereTextureBlendMode!==e&&(this._sphereTextureBlendMode=e,this.markAllDefinesAsDirty())}get toonTexture(){return this._toonTexture}set toonTexture(e){this._toonTexture!==e&&(this._toonTexture=e,this._markAllSubMeshesAsTexturesDirty())}get ignoreDiffuseWhenToonTextureIsNull(){return this._ignoreDiffuseWhenToonTextureIsNull}set ignoreDiffuseWhenToonTextureIsNull(e){this._ignoreDiffuseWhenToonTextureIsNull!==e&&(this._ignoreDiffuseWhenToonTextureIsNull=e,this.markAllDefinesAsDirty())}get applyAmbientColorToDiffuse(){return this._applyAmbientColorToDiffuse}set applyAmbientColorToDiffuse(e){this._applyAmbientColorToDiffuse!==e&&(this._applyAmbientColorToDiffuse=e,this.markAllDefinesAsDirty())}get clampAlpha(){return this._clampAlpha}set clampAlpha(e){this._clampAlpha!==e&&(this._clampAlpha=e,this.markAllDefinesAsDirty())}get useTextureColor(){return this._useTextureColor}set useTextureColor(e){this._useTextureColor!==e&&(this._useTextureColor=e,this.markAllDefinesAsDirty())}get useSphereTextureColor(){return this._useSphereTextureColor}set useSphereTextureColor(e){this._useSphereTextureColor!==e&&(this._useSphereTextureColor=e,this.markAllDefinesAsDirty())}get useToonTextureColor(){return this._useToonTextureColor}set useToonTextureColor(e){this._useToonTextureColor!==e&&(this._useToonTextureColor=e,this.markAllDefinesAsDirty())}_internalMarkAllSubMeshesAsTexturesDirty;_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}isCompatible(e){return!0}constructor(e,t=!0,n=!1,r=!1){super(e,"MmdMaterial",100,new u,t,n,r),this._internalMarkAllSubMeshesAsTexturesDirty=e._dirtyCallbacks[o.Y.MATERIAL_TextureDirtyFlag]}isReadyForSubMesh(e,t){return!this._isEnabled||!(e._areTexturesDirty&&t.texturesEnabled&&this._sphereTexture&&!this._sphereTexture.isReadyOrNotBlocking())}bindForSubMesh(e,t,n,r){if(!this._isEnabled)return;const o=r.materialDefines,i=this._material.isFrozen;e.useUbo&&i&&e.isSync||(o.DIFFUSE&&o.TEXTURE_COLOR&&(e.updateDirectColor4("textureMultiplicativeColor",this.textureMultiplicativeColor),e.updateDirectColor4("textureAdditiveColor",this.textureAdditiveColor)),o.NORMAL&&o.SPHERE_TEXTURE&&o.SPHERE_TEXTURE_COLOR&&(e.updateDirectColor4("sphereTextureMultiplicativeColor",this.sphereTextureMultiplicativeColor),e.updateDirectColor4("sphereTextureAdditiveColor",this.sphereTextureAdditiveColor)),o.TOON_TEXTURE&&o.TOON_TEXTURE_COLOR&&(e.updateDirectColor4("toonTextureMultiplicativeColor",this.toonTextureMultiplicativeColor),e.updateDirectColor4("toonTextureAdditiveColor",this.toonTextureAdditiveColor)),o.SPHERE_TEXTURE&&null!==r.effect&&this._material.bindView(r.effect)),t.texturesEnabled&&(o.NORMAL&&this._sphereTexture&&e.setTexture("sphereSampler",this._sphereTexture),this._toonTexture&&e.setTexture("toonSampler",this._toonTexture))}dispose(e){e&&(this._sphereTexture?.dispose(),this._toonTexture?.dispose())}prepareDefines(e,t,n){if(this._isEnabled){const o=t.texturesEnabled;e.SPHERE_TEXTURE=null!==this._sphereTexture&&o,e.SPHERE_TEXTURE_BLEND_MODE_MULTIPLY=this._sphereTextureBlendMode===r.Multiply,e.SPHERE_TEXTURE_BLEND_MODE_ADD=this._sphereTextureBlendMode===r.Add,e.TOON_TEXTURE=null!==this._toonTexture&&o,e.IGNORE_DIFFUSE_WHEN_TOON_TEXTURE_DISABLED=this._ignoreDiffuseWhenToonTextureIsNull,e.APPLY_AMBIENT_COLOR_TO_DIFFUSE=this._applyAmbientColorToDiffuse,e.CLAMP_ALPHA=this._clampAlpha,e.TEXTURE_COLOR=this._useTextureColor,e.SPHERE_TEXTURE_COLOR=this._useSphereTextureColor,e.TOON_TEXTURE_COLOR=this._useToonTextureColor,e.SDEF=n.useBones&&n.computeBonesUsingShaders&&!!n.skeleton&&n.isVerticesDataPresent(h.V.MatricesSdefCKind)}else e.SPHERE_TEXTURE=!1,e.SPHERE_TEXTURE_BLEND_MODE_MULTIPLY=!1,e.SPHERE_TEXTURE_BLEND_MODE_ADD=!1,e.TOON_TEXTURE=!1,e.IGNORE_DIFFUSE_WHEN_TOON_TEXTURE_DISABLED=!1,e.APPLY_AMBIENT_COLOR_TO_DIFFUSE=!1,e.CLAMP_ALPHA=!1,e.TEXTURE_COLOR=!1,e.SPHERE_TEXTURE_COLOR=!1,e.TOON_TEXTURE_COLOR=!1,e.SDEF=!1}hasTexture(e){return this._sphereTexture===e||this._toonTexture===e}getActiveTextures(e){this._sphereTexture&&e.push(this._sphereTexture),this._toonTexture&&e.push(this._toonTexture)}getAnimatables(e){this._sphereTexture&&this._sphereTexture.animations&&0<this._sphereTexture.animations.length&&e.push(this._sphereTexture),this._toonTexture&&this._toonTexture.animations&&0<this._toonTexture.animations.length&&e.push(this._toonTexture)}getSamplers(e){e.push("sphereSampler","toonSampler")}getAttributes(e,t,n){this._isEnabled&&n.useBones&&n.computeBonesUsingShaders&&n.skeleton&&n.isVerticesDataPresent(h.V.MatricesSdefCKind)&&(e.push(h.V.MatricesSdefCKind),e.push(h.V.MatricesSdefRW0Kind),e.push(h.V.MatricesSdefRW1Kind))}getUniforms(e){return{ubo:[{name:"textureMultiplicativeColor",size:4,type:"vec4"},{name:"textureAdditiveColor",size:4,type:"vec4"},{name:"sphereTextureMultiplicativeColor",size:4,type:"vec4"},{name:"sphereTextureAdditiveColor",size:4,type:"vec4"},{name:"toonTextureMultiplicativeColor",size:4,type:"vec4"},{name:"toonTextureAdditiveColor",size:4,type:"vec4"}]}}getClassName(){return"MmdPluginMaterial"}}c([(0,l.uM)("sphereTexture")],g.prototype,"_sphereTexture",void 0),c([(0,l.lK)("sphereTextureBlendMode")],g.prototype,"_sphereTextureBlendMode",void 0),c([(0,l.uM)("toonTexture")],g.prototype,"_toonTexture",void 0),c([(0,l.lK)("ignoreDiffuseWhenToonTextureIsNull")],g.prototype,"_ignoreDiffuseWhenToonTextureIsNull",void 0),c([(0,l.lK)("applyAmbientColorToDiffuse")],g.prototype,"_applyAmbientColorToDiffuse",void 0),c([(0,l.lK)("clampAlpha")],g.prototype,"_clampAlpha",void 0),(0,d.Y5)("BABYLON.MmdPluginMaterial",g)},3247:(e,t,n)=>{n.d(t,{u:()=>Re}),n(9679),n(4656),n(1318);var r=n(5616),o=n(8506),i=n(492),s=n(5476),a=n(2565),l=n(467),d=n(5662),h=n(9923),c=n(7457),u=n(6945),g=n(3036),p=n(9339),f=n(5041),m=n(7198),x=n(4122);class y{static OverrideEngineCreateEffect(e){const t=e.createEffect.bind(e);e.createEffect=function(e,n,r,o,i,s,a,l,h,c=d.w.GLSL,u){let p;if(p=n.attributes?n:{attributes:n,uniformsNames:r,uniformBuffersNames:[],samplers:o??[],defines:i??"",fallbacks:s??null,onCompiled:a??null,onError:l??null,indexParameters:h??null,shaderLanguage:c,extraInitializationsAsync:u},(p.uniformsNames.includes("mBones")||p.samplers.includes("boneSampler"))&&-1===p.defines.indexOf("#define SDEF")){p.attributes.push(g.V.MatricesSdefCKind),p.attributes.push(g.V.MatricesSdefRW0Kind),p.attributes.push(g.V.MatricesSdefRW1Kind),p.defines+="\n#define SDEF";const e=p.processCodeAfterIncludes;p.processCodeAfterIncludes=e?function(t,n){return n=e(t,n),y.ProcessSdefCode(t,n)}:y.ProcessSdefCode}return t(e,p,this)}}static ProcessSdefCode(e,t){if("vertex"!==e)return t;if(t.includes("finalWorld=finalWorld*influence;")){const e=t.includes("fn main"),n="#define CUSTOM_VERTEX_DEFINITIONS";if(t.includes(n))t=t.replace(n,`${n}\n${e?m.B:p.B}`);else{const n="void main() {";t=t.replace(n,`${e?m.B:p.B}\nvoid main() {`)}const r=new RegExp("finalWorld=finalWorld\\*influence;","g");t=t.replace(r,`${e?x.Z:f.Z}\nfinalWorld=finalWorld*influence;`)}return t}}c.Z.prototype.getMmdOutlineRenderer=function(){return this._mmdOutlineRenderer||(this._mmdOutlineRenderer=new A(this)),this._mmdOutlineRenderer};class A{name="MmdOutline";scene;zOffset=4;zOffsetUnits=0;_engine;_passIdForDrawWrapper;constructor(e){this.scene=e,this._engine=e.getEngine(),this.scene._addComponent(this),this._passIdForDrawWrapper=this._engine.createRenderPassId("Mmd Outline Renderer")}register(){this.scene._afterRenderingMeshStage.registerStep(u.v.STEP_AFTERRENDERINGMESH_OUTLINE,this,this._afterRenderingMesh)}rebuild(){}dispose(){this._engine.releaseRenderPassId(this._passIdForDrawWrapper)}static _ViewMatrix=new Float32Array(9);static _InverseViewProjectionMatrix=new h.uq;render(e,t,n){n=n??this._passIdForDrawWrapper;const r=this.scene,o=r.getEngine(),a=o.getCaps().instancedArrays&&(null!==t.visibleInstances[e._id]&&void 0!==t.visibleInstances[e._id]||e.getRenderingMesh().hasThinInstances);if(!this.isReady(e,a,n))return;const d=e.getMesh(),h=d._internalAbstractMeshDataInfo._actAsRegularMesh?d:null,c=e.getRenderingMesh(),u=h||c,g=e.getMaterial();if(!g||!r.activeCamera)return;const p=e._getDrawWrapper(n),f=s.E.GetEffect(p);o.enableEffect(p),g.useLogarithmicDepth&&f.setFloat("logarithmicDepthConstant",2/(Math.log(r.activeCamera.maxZ+1)/Math.LN2)),f.setFloat("offset",g.outlineWidth),f.setColor4("color",g.outlineColor,g.outlineAlpha);const m=o.getRenderHeight(),x=o.getRenderWidth();f.setFloat2("viewport",x,m);const y=A._ViewMatrix;{const e=r.getViewMatrix().m;y[0]=e[0],y[1]=e[1],y[2]=e[2],y[3]=e[4],y[4]=e[5],y[5]=e[6],y[6]=e[8],y[7]=e[9],y[8]=e[10]}f.setMatrix3x3("view",y),f.setMatrix("viewProjection",r.getTransformMatrix()),f.setMatrix("world",u.getWorldMatrix()),(0,l.f$)(c,f),(0,l.nR)(c,f),c.morphTargetManager&&c.morphTargetManager.isUsingTextureForTargets&&c.morphTargetManager._bind(f),a||c._bind(e,f,g.fillMode);const T=e.getMesh().bakedVertexAnimationManager;if(T&&T.isEnabled&&T.bind(f,a),g&&g.needAlphaTesting()){const e=g.getAlphaTestTexture();e&&(f.setTexture("diffuseSampler",e),f.setMatrix("diffuseMatrix",e.getTextureMatrix()))}(0,i.gS)(f,g,r),f.defines.includes("WORLDPOS_REQUIRED")&&f.setMatrix("inverseViewProjection",r.getTransformMatrix().invertToRef(A._InverseViewProjectionMatrix)),o.setZOffset(this.zOffset),o.setZOffsetUnits(this.zOffsetUnits),c._processRendering(u,e,f,g.fillMode,t,a,((e,t)=>{f.setMatrix("world",t)})),o.setZOffset(0),o.setZOffsetUnits(0)}isReady(e,t,o){o=o??this._passIdForDrawWrapper;const s=[],h=[r.R.PositionKind,r.R.NormalKind],c=e.getMesh(),u=e.getMaterial();if(!u)return!1;const p=c.getScene();u.needAlphaTesting()&&(s.push("#define ALPHATEST"),c.isVerticesDataPresent(r.R.UVKind)&&(h.push(r.R.UVKind),s.push("#define UV1")),c.isVerticesDataPresent(r.R.UV2Kind)&&(h.push(r.R.UV2Kind),s.push("#define UV2"))),u.useLogarithmicDepth&&s.push("#define LOGARITHMICDEPTH"),(0,i.tv)(u,p,s);let f=!1;for(let e=0;e<s.length;++e)if(s[e].includes("CLIPPLANE")){f=!0;break}f&&s.push("#define WORLDPOS_REQUIRED");const m=new a.J;if(c.useBones&&c.computeBonesUsingShaders&&c.skeleton){h.push(r.R.MatricesIndicesKind),h.push(r.R.MatricesWeightsKind),c.numBoneInfluencers>4&&(h.push(r.R.MatricesIndicesExtraKind),h.push(r.R.MatricesWeightsExtraKind)),c.isVerticesDataPresent(g.V.MatricesSdefCKind)&&(h.push(g.V.MatricesSdefCKind),h.push(g.V.MatricesSdefRW0Kind),h.push(g.V.MatricesSdefRW1Kind),s.push("#define SDEF"));const e=c.skeleton;s.push("#define NUM_BONE_INFLUENCERS "+c.numBoneInfluencers),c.numBoneInfluencers>0&&m.addCPUSkinningFallback(0,c),e.isUsingTextureForMatrices?s.push("#define BONETEXTURE"):s.push("#define BonesPerMesh "+(e.bones.length+1))}else s.push("#define NUM_BONE_INFLUENCERS 0");const x=c.morphTargetManager;let A=0;x&&(A=x.numMaxInfluencers||x.numInfluencers,A>0&&(s.push("#define MORPHTARGETS"),s.push("#define NUM_MORPH_INFLUENCERS "+A),x.isUsingTextureForTargets&&s.push("#define MORPHTARGETS_TEXTURE"),(0,l.MF)(h,c,A))),t&&(s.push("#define INSTANCES"),(0,l.te)(h),e.getRenderingMesh().hasThinInstances&&s.push("#define THIN_INSTANCES"));const T=c.bakedVertexAnimationManager;T&&T.isEnabled&&(s.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),t&&h.push("bakedVertexAnimationSettingsInstanced"));const M=e._getDrawWrapper(o,!0),_=M.defines,b=s.join("\n");if(_!==b){const e=["world","mBones","viewport","view","viewProjection","diffuseMatrix","offset","color","logarithmicDepthConstant","morphTargetInfluences","boneTextureWidth","morphTargetCount","morphTargetTextureInfo","morphTargetTextureIndices","bakedVertexAnimationSettings","bakedVertexAnimationTextureSizeInverted","bakedVertexAnimationTime","bakedVertexAnimationTexture"],t=["diffuseSampler","boneSampler","morphTargets","bakedVertexAnimationTexture"];(0,i.TV)(e),f&&e.push("inverseViewProjection");const r=p.getEngine().isWebGPU?d.w.WGSL:d.w.GLSL;M.setEffect(this.scene.getEngine().createEffect("mmdOutline",{attributes:h,uniformsNames:e,uniformBuffersNames:[],samplers:t,defines:b,fallbacks:m,onCompiled:null,onError:null,indexParameters:{maxSimultaneousMorphTargets:A},processCodeAfterIncludes:y.ProcessSdefCode,shaderLanguage:r,extraInitializationsAsync:async()=>{r===d.w.WGSL?await Promise.all([n.e(126).then(n.bind(n,8980)),n.e(126).then(n.bind(n,1870))]):await Promise.all([n.e(71).then(n.bind(n,3357)),n.e(71).then(n.bind(n,5043))])}},this.scene.getEngine()),b)}return M.effect.isReady()}_afterRenderingMesh(e,t,n){const r=t.getMaterial();if(null!==r&&r.renderOutline){const e=this._engine,r=e.getDepthWrite(),i=e.getAlphaMode(),s=e.alphaState.alphaBlend;e.setDepthWrite(!0),e.setAlphaMode(o.Y.ALPHA_COMBINE,!0),e.setState(!0,void 0,void 0,void 0,!!this.scene._mirroredCameraPosition),this.render(t,n,this._passIdForDrawWrapper),e.setAlphaMode(i,!0),e.setDepthWrite(r),e.alphaState.alphaBlend=s}}}var T,M,_=n(6632);class b{log(e){console.log(e)}warn(e){console.warn(e)}error(e){console.error(e)}}class I{isDeviceLittleEndian;_dataView;_decoder;_offset;constructor(e){this.isDeviceLittleEndian=this._getIsDeviceLittleEndian(),this._dataView=new DataView(e),this._decoder=null,this._offset=0}get offset(){return this._offset}set offset(e){this._offset=e}_getIsDeviceLittleEndian(){const e=new Int16Array([256]);return 1===new Int8Array(e.buffer)[1]}swap16Array(e){for(let t=0;t<e.length;++t){const n=e[t];e[t]=(255&n)<<8|n>>8&255}}swap32Array(e){for(let t=0;t<e.length;++t){const n=e[t];e[t]=(255&n)<<24|(65280&n)<<8|n>>8&65280|n>>24&255}}getUint8(){const e=this._dataView.getUint8(this._offset);return this._offset+=1,e}getInt8(){const e=this._dataView.getInt8(this._offset);return this._offset+=1,e}getUint8Array(e){const t=new Uint8Array(this._dataView.buffer,this._offset,e.byteLength);e.set(t),this._offset+=e.byteLength}getUint16(){const e=this._dataView.getUint16(this._offset,!0);return this._offset+=2,e}getUint16Array(e){const t=new Uint8Array(this._dataView.buffer,this._offset,e.byteLength);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(t),this._offset+=e.byteLength,this.isDeviceLittleEndian||this.swap16Array(e)}getInt16(){const e=this._dataView.getInt16(this._offset,!0);return this._offset+=2,e}getUint32(){const e=this._dataView.getUint32(this._offset,!0);return this._offset+=4,e}getUint32Array(e){const t=new Uint8Array(this._dataView.buffer,this._offset,e.byteLength);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(t),this._offset+=e.byteLength,this.isDeviceLittleEndian||this.swap32Array(e)}getInt32(){const e=this._dataView.getInt32(this._offset,!0);return this._offset+=4,e}getInt32Array(e){const t=new Uint8Array(this._dataView.buffer,this._offset,e.byteLength);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(t),this._offset+=e.byteLength,this.isDeviceLittleEndian||this.swap32Array(e)}getFloat32(){const e=this._dataView.getFloat32(this._offset,!0);return this._offset+=4,e}getFloat32Array(e){const t=new Uint8Array(this._dataView.buffer,this._offset,e.byteLength);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(t),this._offset+=e.byteLength,this.isDeviceLittleEndian||this.swap32Array(e)}getFloat32Tuple(e){const t=new Array(e);for(let n=0;n<e;++n)t[n]=this._dataView.getFloat32(this._offset,!0),this._offset+=4;return t}initializeTextDecoder(e){this._decoder=new TextDecoder(e)}getDecoderString(e,t){if(null===this._decoder)throw new Error("TextDecoder is not initialized.");let n=new Uint8Array(this._dataView.buffer,this._offset,e);if(this._offset+=e,t)for(let e=0;e<n.length;++e)if(0===n[e]){n=n.subarray(0,e);break}return this._decoder.decode(n)}getSignatureString(e){const t=new TextDecoder("utf-8"),n=new Uint8Array(this._dataView.buffer,this._offset,e);return this._offset+=e,t.decode(n)}getPaddedArrayOffset(e,t){this._offset+=this._offset%e==0?0:e-this._offset%e;const n=this._offset;return this._offset+=e*t,n}get bytesAvailable(){return this._dataView.byteLength-this._offset}}!function(e){let t;!function(e){let t;!function(e){e[e.Rotate=0]="Rotate",e[e.RotateMove=1]="RotateMove",e[e.Ik=2]="Ik",e[e.Unknown=3]="Unknown",e[e.IkLink=4]="IkLink",e[e.RotateEffect=5]="RotateEffect",e[e.IkTo=6]="IkTo",e[e.Invisible=7]="Invisible",e[e.Twist=8]="Twist",e[e.RotateRatio=9]="RotateRatio"}(t=e.Type||(e.Type={}))}(t=e.Bone||(e.Bone={}))}(T||(T={})),function(e){let t,n,r,o,i,s,a,l,d;!function(e){let t;!function(e){e[e.Utf16le=0]="Utf16le",e[e.Utf8=1]="Utf8",e[e.ShiftJis=2]="ShiftJis"}(t=e.Encoding||(e.Encoding={}))}(t=e.Header||(e.Header={})),function(e){let t;!function(e){e[e.Bdef1=0]="Bdef1",e[e.Bdef2=1]="Bdef2",e[e.Bdef4=2]="Bdef4",e[e.Sdef=3]="Sdef",e[e.Qdef=4]="Qdef"}(t=e.BoneWeightType||(e.BoneWeightType={}))}(n=e.Vertex||(e.Vertex={})),function(e){let t,n;!function(e){e[e.IsDoubleSided=1]="IsDoubleSided",e[e.EnabledGroundShadow=2]="EnabledGroundShadow",e[e.EnabledDrawShadow=4]="EnabledDrawShadow",e[e.EnabledReceiveShadow=8]="EnabledReceiveShadow",e[e.EnabledToonEdge=16]="EnabledToonEdge",e[e.EnabledVertexColor=32]="EnabledVertexColor",e[e.EnabledPointDraw=64]="EnabledPointDraw",e[e.EnabledLineDraw=128]="EnabledLineDraw"}(t=e.Flag||(e.Flag={})),function(e){e[e.Off=0]="Off",e[e.Multiply=1]="Multiply",e[e.Add=2]="Add",e[e.SubTexture=3]="SubTexture"}(n=e.SphereTextureMode||(e.SphereTextureMode={}))}(r=e.Material||(e.Material={})),function(e){let t;!function(e){e[e.UseBoneIndexAsTailPosition=1]="UseBoneIndexAsTailPosition",e[e.IsRotatable=2]="IsRotatable",e[e.IsMovable=4]="IsMovable",e[e.IsVisible=8]="IsVisible",e[e.IsControllable=16]="IsControllable",e[e.IsIkEnabled=32]="IsIkEnabled",e[e.LocalAppendTransform=128]="LocalAppendTransform",e[e.HasAppendRotate=256]="HasAppendRotate",e[e.HasAppendMove=512]="HasAppendMove",e[e.HasAxisLimit=1024]="HasAxisLimit",e[e.HasLocalVector=2048]="HasLocalVector",e[e.TransformAfterPhysics=4096]="TransformAfterPhysics",e[e.IsExternalParentTransformed=8192]="IsExternalParentTransformed"}(t=e.Flag||(e.Flag={}))}(o=e.Bone||(e.Bone={})),function(e){let t,n,r;!function(e){e[e.System=0]="System",e[e.Eyebrow=1]="Eyebrow",e[e.Eye=2]="Eye",e[e.Lip=3]="Lip",e[e.Other=4]="Other"}(t=e.Category||(e.Category={})),function(e){e[e.GroupMorph=0]="GroupMorph",e[e.VertexMorph=1]="VertexMorph",e[e.BoneMorph=2]="BoneMorph",e[e.UvMorph=3]="UvMorph",e[e.AdditionalUvMorph1=4]="AdditionalUvMorph1",e[e.AdditionalUvMorph2=5]="AdditionalUvMorph2",e[e.AdditionalUvMorph3=6]="AdditionalUvMorph3",e[e.AdditionalUvMorph4=7]="AdditionalUvMorph4",e[e.MaterialMorph=8]="MaterialMorph",e[e.FlipMorph=9]="FlipMorph",e[e.ImpulseMorph=10]="ImpulseMorph"}(n=e.Type||(e.Type={})),function(e){let t;!function(e){e[e.Multiply=0]="Multiply",e[e.Add=1]="Add"}(t=e.Type||(e.Type={}))}(r=e.MaterialMorph||(e.MaterialMorph={}))}(i=e.Morph||(e.Morph={})),function(e){let t;!function(e){let t;!function(e){e[e.Bone=0]="Bone",e[e.Morph=1]="Morph"}(t=e.FrameType||(e.FrameType={}))}(t=e.FrameData||(e.FrameData={}))}(s=e.DisplayFrame||(e.DisplayFrame={})),function(e){let t,n;!function(e){e[e.Sphere=0]="Sphere",e[e.Box=1]="Box",e[e.Capsule=2]="Capsule"}(t=e.ShapeType||(e.ShapeType={})),function(e){e[e.FollowBone=0]="FollowBone",e[e.Physics=1]="Physics",e[e.PhysicsWithBone=2]="PhysicsWithBone"}(n=e.PhysicsMode||(e.PhysicsMode={}))}(a=e.RigidBody||(e.RigidBody={})),function(e){let t;!function(e){e[e.Spring6dof=0]="Spring6dof",e[e.Sixdof=1]="Sixdof",e[e.P2p=2]="P2p",e[e.ConeTwist=3]="ConeTwist",e[e.Slider=4]="Slider",e[e.Hinge=5]="Hinge"}(t=e.Type||(e.Type={}))}(l=e.Joint||(e.Joint={})),function(e){let t,n,r;!function(e){e[e.TriMesh=0]="TriMesh",e[e.Rope=1]="Rope"}(t=e.Type||(e.Type={})),function(e){e[e.Blink=1]="Blink",e[e.ClusterCreation=2]="ClusterCreation",e[e.LinkCrossing=4]="LinkCrossing"}(n=e.Flag||(e.Flag={})),function(e){e[e.VertexPoint=0]="VertexPoint",e[e.VertexTwoSided=1]="VertexTwoSided",e[e.VertexOneSided=2]="VertexOneSided",e[e.FaceTwoSided=3]="FaceTwoSided",e[e.FaceOneSided=4]="FaceOneSided"}(r=e.AeroDynamicModel||(e.AeroDynamicModel={}))}(d=e.SoftBody||(e.SoftBody={}))}(M||(M={}));class w{constructor(){}static async ParseAsync(e,t=new b){const n=new I(e);n.initializeTextDecoder("shift-jis");const r=this._ParseHeader(n),o=await this._ParseVerticesAsync(n),i=this._ParseIndices(n),s=this._ParseMaterials(n),a=this._ParseBones(n),l=this._ParseIks(n),d=this._ParseMorphs(n),[h,c]=this._ParseDisplayFrames(n,d);if(0===n.bytesAvailable){const e=[];return{header:r,vertices:o,indices:i,textures:e,materials:this._ConvertMaterials(s,e),bones:this._ConvertBones(a,l,o,h),morphs:d,displayFrames:h,rigidBodies:[],joints:[],softBodies:[]}}0!==n.getUint8()&&this._ParseEnglishNames(n,r,a,d,h,c);const u=this._ParseToonTextures(n),g=this._ConvertMaterials(s,u);if(0===n.bytesAvailable)return{header:r,vertices:o,indices:i,textures:u,materials:g,bones:this._ConvertBones(a,l,o,h),morphs:d,displayFrames:h,rigidBodies:[],joints:[],softBodies:[]};const p=this._ParseRigidBodies(n),f=this._ConvertBones(a,l,o,h,p);this._NormalizeRigidBodyPositions(p,f);const m=this._ParseJoints(n);return n.bytesAvailable>0&&t.warn(`There are ${n.bytesAvailable} bytes left after parsing`),{header:r,vertices:o,indices:i,textures:u,materials:g,bones:f,morphs:d,displayFrames:h,rigidBodies:p,joints:m,softBodies:[]}}static _ParseHeader(e){if(e.bytesAvailable<7)throw new Error("is not pmd file");const t=e.getSignatureString(3);if("Pmd"!==t)throw new Error("is not pmd file");const n=e.getFloat32(),r=e.getDecoderString(20,!0),o=e.getDecoderString(256,!0);return{signature:t,version:n,encoding:M.Header.Encoding.ShiftJis,additionalVec4Count:0,vertexIndexSize:2,textureIndexSize:4,materialIndexSize:4,boneIndexSize:2,morphIndexSize:2,rigidBodyIndexSize:4,modelName:r,englishModelName:"",comment:o,englishComment:""}}static async _ParseVerticesAsync(e){const t=e.getUint32(),n=[];let r=performance.now();for(let o=0;o<t;++o){const t=e.getFloat32Tuple(3),i=e.getFloat32Tuple(3),s=e.getFloat32Tuple(2),a=M.Vertex.BoneWeightType.Bdef2,l={boneIndices:[e.getUint16(),e.getUint16()],boneWeights:e.getUint8()/100},d=0!==e.getUint8();n.push({position:t,normal:i,uv:s,additionalVec4:[],weightType:a,boneWeight:l,edgeScale:d?1:0}),o%1e4==0&&100<performance.now()-r&&(await new Promise((e=>setTimeout(e,0))),r=performance.now())}return n}static _ParseIndices(e){const t=e.getUint32(),n=new Uint16Array(t);return e.getUint16Array(n),n}static _ParseMaterials(e){const t=e.getUint32(),n=[];for(let r=0;r<t;++r){const t=e.getFloat32Tuple(4),r=e.getFloat32(),o=e.getFloat32Tuple(3),i=e.getFloat32Tuple(3),s=e.getInt8(),a=e.getUint8(),l=e.getUint32(),d=e.getDecoderString(20,!0);let h=0;0!==a&&(h|=M.Material.Flag.EnabledToonEdge|M.Material.Flag.EnabledGroundShadow),.98!==t[3]&&(h|=M.Material.Flag.EnabledDrawShadow|M.Material.Flag.EnabledReceiveShadow),t[3]<1&&(h|=M.Material.Flag.IsDoubleSided);let c=M.Material.SphereTextureMode.Off,u="",g="";{const e=d.split("*");for(let t=0;t<e.length;++t){const n=e[t];let r=M.Material.SphereTextureMode.Off;if(""!==n){const e=n.lastIndexOf("."),t=-1!==e?n.substring(e).toLowerCase():"";".sph"===t?r=M.Material.SphereTextureMode.Multiply:".spa"===t&&(r=M.Material.SphereTextureMode.Add)}r!==M.Material.SphereTextureMode.Off?(c=r,g=n):u=n}}const p={name:d,englishName:"",diffuse:t,specular:o,shininess:r,ambient:i,flag:h,edgeColor:[0,0,0,1],edgeSize:1,textureIndex:u,sphereTextureIndex:g,sphereTextureMode:c,isSharedToonTexture:!1,toonTextureIndex:s,comment:"",indexCount:l};n.push(p)}return n}static _ParseBones(e){const t=e.getUint16(),n=[];for(let r=0;r<t;++r){const t={name:e.getDecoderString(20,!0),englishName:"",parentBoneIndex:e.getInt16(),tailIndex:e.getInt16(),type:e.getUint8(),ikIndex:e.getInt16(),position:e.getFloat32Tuple(3)};n.push(t)}return n}static _ParseIks(e){const t=e.getUint16(),n=[];for(let r=0;r<t;++r){const t=e.getUint16(),r=e.getUint16(),o=e.getUint8(),i=e.getUint16(),s=e.getFloat32(),a=[];for(let t=0;t<o;++t)a.push(e.getUint16());const l={boneIndex:t,targetIndex:r,iteration:i,rotationConstraint:s,links:a};n.push(l)}return n}static _ParseMorphs(e){const t=e.getUint16();if(0===t)return[];const n=[];for(let r=0;r<t;++r){const t=e.getDecoderString(20,!0),r=e.getUint32();let o={name:t,englishName:"",category:e.getUint8(),type:M.Morph.Type.VertexMorph};const i=new Int32Array(r),s=new Float32Array(3*r);for(let t=0;t<r;++t)i[t]=e.getUint32(),s[3*t+0]=e.getFloat32(),s[3*t+1]=e.getFloat32(),s[3*t+2]=e.getFloat32();o={...o,indices:i,positions:s},n.push(o)}const r=n.shift().indices;for(let e=0;e<n.length;++e){const t=n[e].indices;for(let e=0;e<t.length;++e){const n=t[e];0<=n&&n<r.length?t[e]=r[n]:t[e]=0}}return n}static _ParseDisplayFrames(e,t){const n=[],r=e.getUint8();for(let o=0;o<r;++o){const r={type:M.DisplayFrame.FrameData.FrameType.Morph,index:e.getUint16()},o={name:t[r.index]?.name??"",englishName:"",isSpecialFrame:!0,frames:[r]};n.push(o)}const o=n.length,i=e.getUint8();for(let t=0;t<i;++t){const t={name:e.getDecoderString(50,!0),englishName:"",isSpecialFrame:!1,frames:void 0};n.push(t)}const s=e.getUint32();for(let t=0;t<s;++t){const t=e.getUint16(),r=n[o+e.getUint8()-1];if(void 0!==r){const e={type:M.DisplayFrame.FrameData.FrameType.Bone,index:t};void 0===r.frames?r.frames=[e]:r.frames.push(e)}}for(let e=o;e<n.length;++e){const t=n[e];void 0===t.frames&&(t.frames=[])}return[n,o]}static _ParseEnglishNames(e,t,n,r,o,i){t.englishModelName=e.getDecoderString(20,!0),t.englishComment=e.getDecoderString(256,!0);for(let t=0;t<n.length;++t)n[t].englishName=e.getDecoderString(20,!0);for(let t=0;t<r.length;++t)r[t].englishName=e.getDecoderString(20,!0);for(let t=i;t<o.length;++t)o[t].englishName=e.getDecoderString(50,!0)}static _ParseToonTextures(e){const t=[];for(let n=0;n<10;++n)t.push(e.getDecoderString(100,!0));return t}static _PathNormalize(e){const t=(e=e.replace(/\\/g,"/")).split("/"),n=[];for(let e=0;e<t.length;++e){const r=t[e];"."!==r&&(".."===r?n.pop():n.push(r))}return n.join("/").toLowerCase()}static _ConvertMaterials(e,t){const n=new Array(t.length);for(let e=0;e<t.length;++e)n[e]=this._PathNormalize(t[e]);for(let r=0;r<e.length;++r){const o=e[r];if(0<=o.toonTextureIndex&&o.toonTextureIndex<t.length){const e=n[o.toonTextureIndex];if(/toon(10|0[0-9])\.bmp/.test(e)){o.isSharedToonTexture=!0;let t=e.substring(e.length-6,e.length-4);"n"===t[0]&&(t=t[1]),o.toonTextureIndex=parseInt(t,10)-1}}}const r=new Map;for(let e=0;e<t.length;++e)r.set(this._PathNormalize(t[e]),e);for(let n=0;n<e.length;++n){const o=e[n];if(""!==o.textureIndex){const e=this._PathNormalize(o.textureIndex);let n=r.get(e);void 0===n&&(n=r.size,r.set(e,n),t.push(o.textureIndex)),o.textureIndex=n}else o.textureIndex=-1;if(""!==o.sphereTextureIndex){const e=this._PathNormalize(o.sphereTextureIndex);let n=r.get(e);void 0===n&&(n=r.size,r.set(e,n),t.push(o.sphereTextureIndex)),o.sphereTextureIndex=n}else o.sphereTextureIndex=-1}return e}static _IkAngleLimitTable=new Map(Object.entries({左ひざ:[-180,-.5,0,0,0,0],右ひざ:[-180,-.5,0,0,0,0]}));static _ConvertBones(e,t,n,r,o){const i=new Map;for(let n=0;n<t.length;++n){const r=t[n].boneIndex;0<=r&&r<e.length&&!i.has(r)&&i.set(r,n)}const s=[];for(let t=0;t<e.length;++t){const n=e[t],r={name:n.name,englishName:n.englishName,position:n.position,parentBoneIndex:n.parentBoneIndex,transformOrder:0,flag:M.Bone.Flag.UseBoneIndexAsTailPosition,tailPosition:n.tailIndex<=0?-1:n.tailIndex,appendTransform:void 0,axisLimit:void 0,localVector:void 0,externalParentTransform:void 0,ik:void 0};let o=i.has(t);switch(r.flag|=M.Bone.Flag.IsRotatable|M.Bone.Flag.IsVisible|M.Bone.Flag.IsControllable,r.flag&=~M.Bone.Flag.IsMovable&~M.Bone.Flag.IsIkEnabled&~M.Bone.Flag.HasAppendRotate&~M.Bone.Flag.HasAxisLimit,n.type){case T.Bone.Type.RotateMove:r.flag|=M.Bone.Flag.IsMovable;break;case T.Bone.Type.Ik:o=!0;break;case T.Bone.Type.RotateEffect:r.flag|=M.Bone.Flag.HasAppendRotate,r.flag&=~M.Bone.Flag.UseBoneIndexAsTailPosition&~M.Bone.Flag.IsVisible,r.appendTransform={parentIndex:n.tailIndex,ratio:.01*n.ikIndex}}o&&(r.flag|=M.Bone.Flag.IsMovable|M.Bone.Flag.IsIkEnabled,r.transformOrder=1),s.push(r)}let a=Math.min(s.length,e.length);for(let t=0;t<a;++t){const n=e[t],r=s[t];if(n.type===T.Bone.Type.Twist){let t=e[n.tailIndex];void 0===t&&(t=e[0]);const o=t.position,i=n.position;r.axisLimit=[o[0]-i[0],o[1]-i[1],o[2]-i[2]];const s=r.axisLimit,a=Math.sqrt(s[0]*s[0]+s[1]*s[1]+s[2]*s[2]);s[0]/=a,s[1]/=a,s[2]/=a,r.flag&=~M.Bone.Flag.UseBoneIndexAsTailPosition}}const l=[];for(let n=0;n<a;++n){const r=s[n];if(0==(r.flag&M.Bone.Flag.IsIkEnabled))continue;let o=0;for(let i=0;i<t.length;++i){const a=t[i];if(a.boneIndex!==n)continue;let d;0===o?(d=r,o+=1):(d={name:r.name+"+",englishName:r.englishName,position:[...r.position],parentBoneIndex:n,transformOrder:r.transformOrder,flag:r.flag&~M.Bone.Flag.IsVisible&~M.Bone.Flag.UseBoneIndexAsTailPosition,tailPosition:[0,0,0],appendTransform:void 0!==r.appendTransform?{...r.appendTransform}:void 0,axisLimit:void 0!==r.axisLimit?[...r.axisLimit]:void 0,localVector:void 0!==r.localVector?{x:[...r.localVector.x],z:[...r.localVector.z]}:void 0,externalParentTransform:r.externalParentTransform,ik:void 0},l.push(d),o+=1),void 0===d.ik&&(d.ik={target:0,iteration:0,rotationConstraint:0,links:[]});{const t=d.ik;t.target=a.targetIndex,t.iteration=a.iteration,t.rotationConstraint=4*a.rotationConstraint;const n=a.links;for(let r=0;r<n.length;++r){const o=n[r];if(0<=o&&o<s.length){const n={target:o,limitation:void 0};if(0<=o&&o<e.length){const t=e[o].name,r=this._IkAngleLimitTable.get(t);void 0!==r&&(n.limitation={minimumAngle:[r[0],r[2],r[4]],maximumAngle:[r[1],r[3],r[5]]})}t.links.push(n)}}}}}s.push(...l),a=Math.min(s.length,e.length);const d=[];for(let e=0;e<a;++e)if(0!=(s[e].flag&M.Bone.Flag.IsIkEnabled))for(let n=0;n<t.length;++n)if(t[n].boneIndex===e){d.push([e,n]);break}let h=!0;for(let e=0;e<d.length-1;++e)if(d[e][1]>d[e+1][1]){h=!1;break}if(!h){d.sort(((e,t)=>e[1]-t[1]));const e=new Array(d.length);for(let t=1;t<d.length;++t){let n=!0;(d[t-1][0]>d[t][0]||void 0!==e[t-1])&&(n=!1),n||(e[t]=s[d[t-1][0]])}const t=new Map;for(let n=0;n<e.length;++n){const r=e[n];void 0===r||t.has(r)||t.set(r,n)}const i=new Array(d.length);for(let e=0;e<d.length;++e)i[e]=s[d[e][0]];const a=s.slice();for(let n=0;0<t.size;++n){for(let n=1;n<d.length;++n)if(void 0!==e[n]&&void 0!==i[n]&&!t.has(i[n])){const r=i[n],o=s.indexOf(r);s.splice(o,1);const a=s.indexOf(e[n])+1;s.splice(a,0,r),t.delete(r)}if(d.length<n)break}const l=new Map;for(let e=0;e<s.length;++e){const t=s[e];l.set(t,e)}for(let e=0;e<n.length;++e){const t=n[e].boneWeight;if("number"==typeof t.boneIndices)t.boneIndices=l.get(a[t.boneIndices]);else{const e=t.boneIndices;for(let t=0;t<e.length;++t)e[t]=l.get(a[e[t]])}}for(let e=0;e<s.length;++e){const t=s[e];if(t.parentBoneIndex=l.get(a[t.parentBoneIndex]),"number"==typeof t.tailPosition&&(t.tailPosition=l.get(a[t.tailPosition])),t.appendTransform&&(t.appendTransform.parentIndex=l.get(a[t.appendTransform.parentIndex])),t.ik){t.ik.target=l.get(a[t.ik.target]);const e=t.ik.links;for(let t=0;t<e.length;++t)e[t].target=l.get(a[e[t].target])}}for(let e=0;e<r.length;++e){const t=r[e].frames;if(void 0!==t)for(let e=0;e<t.length;++e){const n=t[e];n.type===M.DisplayFrame.FrameData.FrameType.Bone&&(n.index=l.get(a[n.index]))}}if(void 0!==o)for(let e=0;e<o.length;++e){const t=o[e];t.boneIndex=l.get(a[t.boneIndex])}}let c=!1;for(let e=0;e<s.length;++e){let t=s[e];for(let n=0;n<s.length;++n){const r=s[n].parentBoneIndex;if(r===e){c=!0;break}if(t=s[r],void 0===t)break}if(c)break}if(c)for(let e=0;e<s.length;++e){let e=!1;for(let t=0;t<s.length;++t){const n=s[t];let r=n,o=n.transformOrder;for(;;){const t=s[r.parentBoneIndex];if(void 0===t)break;o<t.transformOrder&&(o=t.transformOrder,e=!0),r=t}n.transformOrder=o}if(!e)break}for(let e=0;e<s.length;++e){const t=s[e];0!=(t.flag&M.Bone.Flag.UseBoneIndexAsTailPosition)?"number"!=typeof t.tailPosition&&(t.tailPosition=-1):"number"==typeof t.tailPosition&&(t.tailPosition=[0,0,0])}return s}static _ParseRigidBodies(e){const t=e.getUint32(),n=[];for(let r=0;r<t;++r){const t={name:e.getDecoderString(20,!0),englishName:"",boneIndex:e.getInt16(),collisionGroup:e.getUint8(),collisionMask:e.getUint16(),shapeType:e.getUint8(),shapeSize:e.getFloat32Tuple(3),shapePosition:e.getFloat32Tuple(3),shapeRotation:e.getFloat32Tuple(3),mass:e.getFloat32(),linearDamping:e.getFloat32(),angularDamping:e.getFloat32(),repulsion:e.getFloat32(),friction:e.getFloat32(),physicsMode:e.getUint8()};n.push(t)}return n}static _NormalizeRigidBodyPositions(e,t){for(let n=0;n<e.length;++n){const r=e[n],o=t[r.boneIndex<0?0:r.boneIndex].position,i=r.shapePosition;i[0]+=o[0],i[1]+=o[1],i[2]+=o[2]}}static _ParseJoints(e){const t=e.getUint32(),n=[];for(let r=0;r<t;++r){const t=e.getDecoderString(20,!0),r=e.getInt32(),o=e.getInt32(),i=e.getFloat32Tuple(3),s=e.getFloat32Tuple(3),a=e.getFloat32Tuple(3),l=e.getFloat32Tuple(3),d=e.getFloat32Tuple(3),h=e.getFloat32Tuple(3),c=e.getFloat32Tuple(3),u=e.getFloat32Tuple(3),g={name:t,englishName:"",type:M.Joint.Type.Spring6dof,rigidbodyIndexA:r,rigidbodyIndexB:o,position:i,rotation:s,positionMin:a,positionMax:l,rotationMin:d,rotationMax:h,springPosition:c,springRotation:u};n.push(g)}return n}}const v={".pmd":{isBinary:!0}};var E=n(1359),S=n(5530),C=n(6803),F=n(998),B=n(706),U=n(216),R=n(7762),D=n(6504),P=n(3346),k=n(2564),V=n(1137),L=n(8986),O=n(6041),N=n(2781),z=n(9848),W=n(2940);class K{static Data=["data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII="]}function H(e){const t=(e=e.replace(/\\/g,"/")).split("/"),n=[];for(let e=0;e<t.length;++e){const r=t[e];"."!==r&&(".."===r?n.pop():n.push(r))}return n.join("/")}class G{uniqueId;leftLoadCount;isRequesting;errorTextureDatas;constructor(e){this.uniqueId=e,this.leftLoadCount=0,this.isRequesting=!0,this.errorTextureDatas=[]}}class Q{observable;hasLoadError;constructor(){this.observable=new z.cP,this.hasLoadError=!1}}class j{cacheKey;_scene;_assetContainer;_textureName;_options;_onLoad;_onError;_texture;constructor(e,t,n,r,o,i,s,a,l){this.cacheKey=e,this._scene=t,this._assetContainer=n,this._textureName=o,this._options=s,this._onLoad=a,this._onError=l,this._texture=null,i||t._loadFile(r,(e=>{this._createTexture(t,n,o,e,s,a,((e,t)=>{l?.(e,t)}))}),void 0,!0,!0,((e,t)=>{l?.(e?e.status+" "+e.statusText:"",t)}))}loadFromArrayBuffer(e){this._createTexture(this._scene,this._assetContainer,this._textureName,e,this._options,this._onLoad,((e,t)=>{this._onError?.(e,t)}))}_onDisposeCallback=null;registerOnDisposeCallback(e){this._onDisposeCallback=e,this._texture.onDisposeObservable.addOnce(e)}unregisterOnDisposeCallback(){const e=this._onDisposeCallback;return null===e?null:(this._onDisposeCallback=null,this._texture.onDisposeObservable.removeCallback(e),e)}_createTexture(e,t,n,r,o,i,s){e._blockEntityCollection=!!t;const a={noMipmap:o.noMipmap,invertY:o.invertY,samplingMode:o.samplingMode,onLoad:()=>{null===this._texture?null!==i&&W._.SetImmediate(i):i?.()},onError:s,buffer:r,deleteBuffer:o.deleteBuffer,format:o.format,mimeType:o.mimeType},l=this._texture=new N.g("data:"+n,e,a);l._parentContainer=t,e._blockEntityCollection=!1,t?.textures.push(l),l.name=n}get texture(){return this._texture}}class Y{onModelTextureLoadedObservable=new Map;textureCache=new Map;_textureLoadInfoMap=new Map;_loadingModels=new Map;_errorTexturesReferenceCount=new Map;_incrementLeftLoadCount(e){let t=this._loadingModels.get(e);void 0===t&&(t=new G(e),this._loadingModels.set(e,t)),t.leftLoadCount+=1;let n=this.onModelTextureLoadedObservable.get(e);return void 0===n&&(n=new z.cP,this.onModelTextureLoadedObservable.set(e,n)),t}_decrementLeftLoadCount(e){if(e.leftLoadCount-=1,!e.isRequesting&&0===e.leftLoadCount){this._removeErrorTexturesReferenceCount(e.uniqueId),this._loadingModels.delete(e.uniqueId);const t=this.onModelTextureLoadedObservable.get(e.uniqueId);t?.notifyObservers(),t?.clear(),this.onModelTextureLoadedObservable.delete(e.uniqueId)}}loadModelTexturesEnd(e){const t=this._loadingModels.get(e);if(void 0!==t&&(t.isRequesting=!1,0===t.leftLoadCount)){this._removeErrorTexturesReferenceCount(e),this._loadingModels.delete(e);const t=this.onModelTextureLoadedObservable.get(e);t?.notifyObservers(),t?.clear(),this.onModelTextureLoadedObservable.delete(e)}}_addErrorTextureReferenceCount(e,t){this._loadingModels.get(e).errorTextureDatas.push(t),this._errorTexturesReferenceCount.set(t,(this._errorTexturesReferenceCount.get(t)??0)+1)}_removeErrorTexturesReferenceCount(e){const t=this._loadingModels.get(e);for(let e=0;e<t.errorTextureDatas.length;++e){const n=t.errorTextureDatas[e],r=this._errorTexturesReferenceCount.get(n)-1;0===r?null!==n.texture?n.texture.dispose():(this._textureLoadInfoMap.delete(n.cacheKey),this.textureCache.delete(n.cacheKey),this._errorTexturesReferenceCount.delete(n)):this._errorTexturesReferenceCount.set(n,r)}}_handleTextureOnDispose(e){e.registerOnDisposeCallback((()=>{this._textureLoadInfoMap.delete(e.cacheKey),this.textureCache.delete(e.cacheKey),this._errorTexturesReferenceCount.delete(e)}))}_createTextureCacheKey(e,t){const n=e.lastIndexOf(".");let r="";return-1!==n&&(r=e.substring(n),e=e.substring(0,n)),e+ +(t.noMipmap??!1)+ +(t.invertY??!0)+(t.samplingMode??N.g.TRILINEAR_SAMPLINGMODE)+(t.format??o.Y.TEXTUREFORMAT_RGBA)+r}async _loadTextureAsyncInternal(e,t,n,r,o,i,s){const a=this._incrementLeftLoadCount(e),l=this._createTextureCacheKey(t,s);let d=this._textureLoadInfoMap.get(l);void 0===d&&(d=new Q,this._textureLoadInfoMap.set(l,d));let h=this.textureCache.get(l);if(void 0===h&&!d.hasLoadError){const a=null!==r?K.Data[r]:t;h=new j(l,o,i,a,t,null!==n,s,(()=>{this._handleTextureOnDispose(h),d.hasLoadError=!1,d.observable.notifyObservers(!1),d.observable.clear()}),((t,n)=>{null!==h.texture&&this._handleTextureOnDispose(h),this._addErrorTextureReferenceCount(e,h),d.hasLoadError=!0,d.observable.notifyObservers(!0),d.observable.clear()})),this.textureCache.set(l,h);const c=n instanceof Blob?await n.arrayBuffer():n;null!==c&&h.loadFromArrayBuffer(c)}return null!==h.texture&&h.texture.isReady()?(this._decrementLeftLoadCount(a),d.hasLoadError?null:h.texture):new Promise((e=>{d.observable.addOnce((t=>{this._decrementLeftLoadCount(a),e(t?null:h.texture)}))}))}async loadTextureAsync(e,t,n,r,o,i){let s;"number"==typeof n?((n<-1||9<n)&&(n=-1),n+=1,s=!0):s=!1;const a=s?s?"file:shared_toon_texture_"+n:n:H(t+n);return await this._loadTextureAsyncInternal(e,a,null,s?n:null,r,o,i)}async loadTextureFromBufferAsync(e,t,n,r,o,i,s=!0){return s&&(t=H(t)),await this._loadTextureAsyncInternal(e,t,n,null,r,o,i)}}var X=n(56),$=n(9259),q=n(6877),J=n(6552),Z=n(426),ee=function(e,t,n,r){var o,i=arguments.length,s=i<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(s=(i<3?o(s):i>3?o(t,n,s):o(t,n))||s);return i>3&&s&&Object.defineProperty(t,n,s),s};class te{isMock=!0;sphereTexture=null;sphereTextureBlendMode=Z.rw.Add;toonTexture=null;ignoreDiffuseWhenToonTextureIsNull=!1;applyAmbientColorToDiffuse=!0;clampAlpha=!0;textureMultiplicativeColor=new O.ov(1,1,1,1);textureAdditiveColor=new O.ov(0,0,0,0);sphereTextureMultiplicativeColor=new O.ov(1,1,1,1);sphereTextureAdditiveColor=new O.ov(0,0,0,0);toonTextureMultiplicativeColor=new O.ov(1,1,1,1);toonTextureAdditiveColor=new O.ov(0,0,0,0);useTextureColor=!1;useSphereTextureColor=!1;useToonTextureColor=!1}class ne extends X.F{_pluginMaterial;_renderOutline=!1;outlineWidth=.01;outlineColor=new O.v9(0,0,0);outlineAlpha=1;_disposed=!1;constructor(e,t,n=!1){super(e,t,n),this.specularColor=new O.v9(0,0,0),(this._pluginMaterial=new te).ignoreDiffuseWhenToonTextureIsNull=!0,this._initPluginShaderSourceAsync(this._shaderLanguage)}async _initPluginShaderSourceAsync(e){const t=e===d.w.GLSL?(await Promise.all([n.e(71),n.e(257)]).then(n.bind(n,2968))).MmdPluginMaterial:(await Promise.all([n.e(126),n.e(638)]).then(n.bind(n,9325))).MmdPluginMaterial;if(this._disposed)return;const r=this._pluginMaterial,o=this._pluginMaterial=new t(this);o.isEnabled=!0,o.sphereTexture=r.sphereTexture,o.sphereTextureBlendMode=r.sphereTextureBlendMode,o.toonTexture=r.toonTexture,o.ignoreDiffuseWhenToonTextureIsNull=r.ignoreDiffuseWhenToonTextureIsNull,o.applyAmbientColorToDiffuse=r.applyAmbientColorToDiffuse,o.clampAlpha=r.clampAlpha,o.textureMultiplicativeColor=r.textureMultiplicativeColor,o.textureAdditiveColor=r.textureAdditiveColor,o.sphereTextureMultiplicativeColor=r.sphereTextureMultiplicativeColor,o.sphereTextureAdditiveColor=r.sphereTextureAdditiveColor,o.toonTextureMultiplicativeColor=r.toonTextureMultiplicativeColor,o.toonTextureAdditiveColor=r.toonTextureAdditiveColor,o.useTextureColor=r.useTextureColor,o.useSphereTextureColor=r.useSphereTextureColor,o.useToonTextureColor=r.useToonTextureColor}dispose(e,t){super.dispose(e,t),this._disposed=!0}isReadyForSubMesh(e,t,n){return!this._pluginMaterial.isMock&&super.isReadyForSubMesh(e,t,n)}get sphereTexture(){return this._pluginMaterial.sphereTexture}set sphereTexture(e){this._pluginMaterial.sphereTexture=e}get sphereTextureBlendMode(){return this._pluginMaterial.sphereTextureBlendMode}set sphereTextureBlendMode(e){this._pluginMaterial.sphereTextureBlendMode=e}get toonTexture(){return this._pluginMaterial.toonTexture}set toonTexture(e){this._pluginMaterial.toonTexture=e}get ignoreDiffuseWhenToonTextureIsNull(){return this._pluginMaterial.ignoreDiffuseWhenToonTextureIsNull}set ignoreDiffuseWhenToonTextureIsNull(e){this._pluginMaterial.ignoreDiffuseWhenToonTextureIsNull=e}get applyAmbientColorToDiffuse(){return this._pluginMaterial.applyAmbientColorToDiffuse}set applyAmbientColorToDiffuse(e){this._pluginMaterial.applyAmbientColorToDiffuse=e}get clampAlpha(){return this._pluginMaterial.clampAlpha}set clampAlpha(e){this._pluginMaterial.clampAlpha=e}get textureMultiplicativeColor(){return this._pluginMaterial.useTextureColor=!0,this._pluginMaterial.textureMultiplicativeColor}set textureMultiplicativeColor(e){this._pluginMaterial.useTextureColor=!0,this._pluginMaterial.textureMultiplicativeColor=e}get textureAdditiveColor(){return this._pluginMaterial.useTextureColor=!0,this._pluginMaterial.textureAdditiveColor}set textureAdditiveColor(e){this._pluginMaterial.useTextureColor=!0,this._pluginMaterial.textureAdditiveColor=e}get sphereTextureMultiplicativeColor(){return this._pluginMaterial.useSphereTextureColor=!0,this._pluginMaterial.sphereTextureMultiplicativeColor}set sphereTextureMultiplicativeColor(e){this._pluginMaterial.useSphereTextureColor=!0,this._pluginMaterial.sphereTextureMultiplicativeColor=e}get sphereTextureAdditiveColor(){return this._pluginMaterial.useSphereTextureColor=!0,this._pluginMaterial.sphereTextureAdditiveColor}set sphereTextureAdditiveColor(e){this._pluginMaterial.useSphereTextureColor=!0,this._pluginMaterial.sphereTextureAdditiveColor=e}get toonTextureMultiplicativeColor(){return this._pluginMaterial.useToonTextureColor=!0,this._pluginMaterial.toonTextureMultiplicativeColor}set toonTextureMultiplicativeColor(e){this._pluginMaterial.useToonTextureColor=!0,this._pluginMaterial.toonTextureMultiplicativeColor=e}get toonTextureAdditiveColor(){return this._pluginMaterial.useToonTextureColor=!0,this._pluginMaterial.toonTextureAdditiveColor}set toonTextureAdditiveColor(e){this._pluginMaterial.useToonTextureColor=!0,this._pluginMaterial.toonTextureAdditiveColor=e}get renderOutline(){return this._renderOutline}set renderOutline(e){e&&this.getScene().getMmdOutlineRenderer?.(),this._renderOutline=e}needAlphaBlending(){return!this._disableAlphaBlending&&(super.needAlphaBlending()||null!==this._pluginMaterial.sphereTexture&&this._pluginMaterial.sphereTextureBlendMode===Z.rw.Multiply)}clone(e,t=!0,n=""){const r=q.p.Clone((()=>new ne(e,this.getScene())),this,{cloneTexturesOnlyOnce:t});return r.name=e,r.id=e,this.stencil.copyTo(r.stencil),this._clonePlugins(r,n),r}static Parse(e,t,n){const r=q.p.Parse((()=>new ne(e.name,t)),e,t,n);return e.stencil&&r.stencil.parse(e.stencil,t,n),L.i._ParsePlugins(e,r,t,n),r}}ee([(0,$.lK)("renderOutline")],ne.prototype,"_renderOutline",void 0),ee([(0,$.lK)()],ne.prototype,"outlineWidth",void 0),ee([(0,$.jT)()],ne.prototype,"outlineColor",void 0),ee([(0,$.lK)()],ne.prototype,"outlineAlpha",void 0),(0,J.Y5)("BABYLON.MmdStandardMaterial",ne);class re{files;_fileRootId;_fileMap=new Map;constructor(e,t,n){if(t=H(t),this.files=e,this._fileRootId=n,0!==e.length)if(e[0]instanceof File)for(const r of e){const e=H(r.webkitRelativePath);if(!e.startsWith(t))continue;const o=n+H(e.slice(t.length));this._fileMap.set(H(o).toUpperCase(),r)}else for(const t of e){const e=n+H(t.relativePath);this._fileMap.set(H(e).toUpperCase(),t)}}createFullPath(e){return this._fileRootId+H(e)}resolve(e){const t=H(e);return this._fileMap.get(t.toUpperCase())}}var oe,ie,se=n(917),ae=n(4008);!function(e){e[e.Opaque=L.i.MATERIAL_OPAQUE]="Opaque",e[e.AlphaTest=L.i.MATERIAL_ALPHATEST]="AlphaTest",e[e.AlphaBlend=L.i.MATERIAL_ALPHABLEND]="AlphaBlend"}(oe||(oe={}));class le{_scene;_renderTargetTexture;_resultPixelsBuffer;constructor(e,t=512){this._scene=e;const n=e.getEngine(),r=this._renderTargetTexture=new ae.$("texture_alpha_checker",t,e,{generateDepthBuffer:!1,generateStencilBuffer:!1,generateMipMaps:!1,type:o.Y.TEXTURETYPE_UNSIGNED_BYTE,format:n.isWebGPU||n.version>1?o.Y.TEXTUREFORMAT_RED:o.Y.TEXTUREFORMAT_RGBA,doNotChangeAspectRatio:!0});r.noPrePassRenderer=!0,r.anisotropicFilteringLevel=1,r.renderParticles=!1,r.optimizeUVAllocation=!0,r.ignoreCameraViewport=!0,r.clearColor=new O.ov(0,0,0,1),this._resultPixelsBuffer=new Uint8Array(t*t*4)}async _renderTexture(e,t,n){const r=le._GetShader(this._scene);r.setTexture("textureSampler",e);let o=null;null!==n&&(o=t.subMeshes,t.subMeshes=[t.subMeshes[n]]);const i=this._renderTargetTexture;i.renderList=[t],i.setMaterialForRendering(t,r);const s=t._internalAbstractMeshDataInfo._currentLODIsUpToDate,a=t._internalAbstractMeshDataInfo._currentLOD;t._internalAbstractMeshDataInfo._currentLODIsUpToDate=!0,t._internalAbstractMeshDataInfo._currentLOD=t;const l=t._nodeDataStorage._isEnabled,d=t._nodeDataStorage._isParentEnabled;t._nodeDataStorage._isEnabled=!0,t._nodeDataStorage._isParentEnabled=!0,i.render(!1,!1),t._nodeDataStorage._isParentEnabled=d,t._nodeDataStorage._isEnabled=l,t._internalAbstractMeshDataInfo._currentLOD=a,t._internalAbstractMeshDataInfo._currentLODIsUpToDate=s;const h=r.getEffect();t.geometry._releaseVertexArrayObject(h);const c=t.subMeshes;for(let e=0,t=c.length;e<t;++e)c[e]._removeDrawWrapper(i.renderPassId,!0);null!==o&&(t.subMeshes=o);const u=this._resultPixelsBuffer;return await i.readPixels(void 0,void 0,u),u}_blockRendering=!1;_taskQueue=[];async hasTranslucentFragmentsOnGeometry(e,t,n,r,o){if(!e.isReady())throw new Error("Texture is not ready");this._blockRendering&&await new Promise((e=>{this._taskQueue.push(e)})),this._blockRendering=!0;const i=await this._renderTexture(e,t,n);let s=0,a=0,l=0;for(let e=0;e<i.length;e+=4){const t=i[e];s=Math.max(s,t),0<t&&t<255&&(a+=t,l+=1)}0!==l&&(a/=l),this._blockRendering=!1;const d=this._taskQueue.shift();return void 0!==d&&d(),s<r?oe.Opaque:a+o<s?oe.AlphaTest:oe.AlphaBlend}async hasFragmentsOnlyOpaqueOnGeometry(e,t,n){if(!e.isReady())throw new Error("Texture is not ready");this._blockRendering&&await new Promise((e=>{this._taskQueue.push(e)})),this._blockRendering=!0;const r=await this._renderTexture(e,t,n);for(let e=0;e<r.length;e+=4)if(0!==r[e]){this._blockRendering=!1;const e=this._taskQueue.shift();return void 0!==e&&e(),!1}this._blockRendering=!1;const o=this._taskQueue.shift();return void 0!==o&&o(),!0}dispose(){this._renderTargetTexture.dispose()}static _GetShader(e){if(!e._textureAlphaCheckerShader){const t=e.getEngine().isWebGPU?d.w.WGSL:d.w.GLSL,r=new se.B("textureAlphaChecker",e,{vertex:"textureAlphaChecker",fragment:"textureAlphaChecker"},{needAlphaBlending:!1,needAlphaTesting:!1,attributes:["uv"],uniforms:[],samplers:["textureSampler"],shaderLanguage:t,extraInitializationsAsync:async()=>{t===d.w.WGSL?await Promise.all([n.e(126).then(n.bind(n,1306)),n.e(126).then(n.bind(n,6876))]):await Promise.all([n.e(71).then(n.bind(n,1838)),n.e(71).then(n.bind(n,71))])}});r.backFaceCulling=!1,r.alphaMode=o.Y.ALPHA_DISABLE,e.onDisposeObservable.add((()=>{e._textureAlphaCheckerShader?.dispose(),e._textureAlphaCheckerShader=null})),e._textureAlphaCheckerShader=r}return e._textureAlphaCheckerShader}static DisposeShader(e){e._textureAlphaCheckerShader?.dispose(),e._textureAlphaCheckerShader=null}}!function(e){e[e.DepthWriteAlphaBlendingWithEvaluation=0]="DepthWriteAlphaBlendingWithEvaluation",e[e.DepthWriteAlphaBlending=1]="DepthWriteAlphaBlending",e[e.AlphaEvaluation=2]="AlphaEvaluation"}(ie||(ie={}));class de{renderMethod=ie.DepthWriteAlphaBlendingWithEvaluation;forceDisableAlphaEvaluation=!1;alphaThreshold=195;alphaBlendThreshold=100;alphaEvaluationResolution=512;deleteTextureBufferAfterLoad=!0;_textureLoader=new Y;nextStartingAlphaIndex=65536;alphaIndexIncrementsPerModel=1024;_setMeshesAlphaIndex(e){let t=this.nextStartingAlphaIndex;for(let n=0;n<e.length;++n)e[n].alphaIndex=t,t+=1;this.nextStartingAlphaIndex+=this.alphaIndexIncrementsPerModel}buildMaterials(e,t,n,r,o,i,s,a,l,d,h,c,u,g,p){this.renderMethod!==ie.DepthWriteAlphaBlendingWithEvaluation&&this.renderMethod!==ie.DepthWriteAlphaBlending||this._setMeshesAlphaIndex(l);const f=d.blockMaterialDirtyMechanism;d._forceBlockMaterialDirtyMechanism(!0);let m=null;const x=()=>null!==m?m:this.forceDisableAlphaEvaluation?null:m=new le(d,this.alphaEvaluationResolution),y=new re(s,o,i),A=[],T={lengthComputable:!0,loaded:0,total:3*t.length},M=()=>{T.loaded+=1,g?.(T)},_=[];for(let i=0;i<t.length;++i){const s=t[i];d._blockEntityCollection=!!h;const l=new ne(s.name,d);l._parentContainer=h,d._blockEntityCollection=!1,h?.materials.push(l);{const t=[],c=this.loadGeneralScalarProperties(l,s,a[i]);void 0!==c&&t.push(c);const g=this.loadDiffuseTexture(e,l,s,r,n[s.textureIndex]??null,d,h,o,y,u,M),p=()=>this.setAlphaBlendMode(l,s,a[i],u,x);if(void 0!==g){const e=g.then(p);t.push(e)}else{const e=p();void 0!==e&&t.push(e)}const f=this.loadSphereTexture(e,l,s,r,n[s.sphereTextureIndex]??null,d,h,o,y,u,M);void 0!==f&&t.push(f);const m=this.loadToonTexture(e,l,s,r,n[s.toonTextureIndex]??null,d,h,o,y,u,M);void 0!==m&&t.push(m);const T=this.loadOutlineRenderingProperties(l,s,u);void 0!==T&&t.push(T),A.push(...t),Promise.all(t).then((()=>{this.afterBuildSingleMaterial(l,i,s,r,n,d,o)}))}_.push(l)}this._textureLoader.loadModelTexturesEnd(e);const b=this._textureLoader.onModelTextureLoadedObservable.get(e);return void 0!==b?b.addOnce((()=>{Promise.all(A).then((()=>{m?.dispose(),d._forceBlockMaterialDirtyMechanism(f),null!==c&&this._buildTextureNameMap(t,_,r,n,c),p?.()}))})):Promise.all(A).then((()=>{m?.dispose(),d._forceBlockMaterialDirtyMechanism(f),null!==c&&this._buildTextureNameMap(t,_,r,n,c),p?.()})),_}_buildTextureNameMap(e,t,n,r,o){for(let i=0;i<e.length;++i){const s=e[i],a=t[i],l=n[r[s.textureIndex]?.imagePathIndex];if(void 0!==l){const e=a.diffuseTexture;null!==e&&o.set(e,l)}const d=n[r[s.sphereTextureIndex]?.imagePathIndex];if(void 0!==d){const e=a.sphereTexture;null!==e&&o.set(e,d)}const h=n[r[s.toonTextureIndex]?.imagePathIndex];if(void 0!==h){const e=a.toonTexture;null!==e&&o.set(e,h)}}}loadGeneralScalarProperties=(e,t,n)=>{const r=t.diffuse;e.diffuseColor=new O.v9(r[0],r[1],r[2]);const o=t.specular;e.specularColor=new O.v9(o[0],o[1],o[2]);const i=t.ambient;e.ambientColor=new O.v9(i[0],i[1],i[2]);const s=t.diffuse[3];if(e.alpha=s,0===s)for(let e=0;e<n.length;++e){const t=n[e];void 0!==t.isVisible&&(t.isVisible=!1)}e.specularPower=t.shininess};loadDiffuseTexture=async(e,t,n,r,i,s,a,l,d,h,c)=>{t.backFaceCulling=!(n.flag&M.Material.Flag.IsDoubleSided);const u=r[i?.imagePathIndex??-1];if(void 0!==u){const n=d.createFullPath(u);let r;const g=d.resolve(n);r=void 0!==g?await this._textureLoader.loadTextureFromBufferAsync(e,n,g instanceof File?g:g.data,s,a,{...i,deleteBuffer:this.deleteTextureBufferAfterLoad,format:o.Y.TEXTUREFORMAT_RGBA,mimeType:g instanceof File?g.type:g.mimeType}):await this._textureLoader.loadTextureAsync(e,l,u,s,a,{...i,deleteBuffer:this.deleteTextureBufferAfterLoad,format:o.Y.TEXTUREFORMAT_RGBA});const p=r;null!==p?t.diffuseTexture=p:h.error(`Failed to load diffuse texture: ${n}`),c?.()}else c?.()};async _evaluateDiffuseTextureTransparencyMode(e,t,n,r,o){let i=Number.MIN_SAFE_INTEGER;if(this.renderMethod===ie.DepthWriteAlphaBlendingWithEvaluation){let r=t>>4&3;if(0==(3^r)&&(r=-1),-1===r){i=L.i.MATERIAL_OPAQUE;const t=o();if(null!==t)for(let r=0;r<n.length;++r){const o=n[r];if(!await t.hasFragmentsOnlyOpaqueOnGeometry(e,o?.mesh??o,void 0!==o?.subMeshIndex?o.subMeshIndex:null)){i=L.i.MATERIAL_ALPHABLEND;break}}}else i=0===r?L.i.MATERIAL_OPAQUE:L.i.MATERIAL_ALPHABLEND}else if(this.renderMethod===ie.AlphaEvaluation){let r=15&t;if(0==(15^r)&&(r=-1),-1!==r)i=r;else{const t=o();if(null!==t)for(let r=0;r<n.length;++r){const o=n[r],s=await t.hasTranslucentFragmentsOnGeometry(e,o?.mesh??o,void 0!==o?.subMeshIndex?o.subMeshIndex:null,this.alphaThreshold,this.alphaBlendThreshold);i<s&&(i=s)}}}else r.warn(`Unknown shading method for evaluating transparency mode: ${this.renderMethod}`);return i!==Number.MIN_SAFE_INTEGER?i:null}setAlphaBlendMode=async(e,t,n,r,o)=>{if(this.renderMethod===ie.DepthWriteAlphaBlending)return e.diffuseTexture&&(e.diffuseTexture.hasAlpha=!0,e.useAlphaFromDiffuseTexture=!0),e.transparencyMode=L.i.MATERIAL_ALPHABLEND,void(e.forceDepthWrite=!0);if(this.renderMethod===ie.DepthWriteAlphaBlendingWithEvaluation&&e.alpha<1)return e.diffuseTexture&&(e.diffuseTexture.hasAlpha=!0,e.useAlphaFromDiffuseTexture=!0),e.transparencyMode=L.i.MATERIAL_ALPHABLEND,void(e.forceDepthWrite=!0);const i=e.diffuseTexture,s=t.evaluatedTransparency??-1;if(null!==i){const t=await this._evaluateDiffuseTextureTransparencyMode(i,s,n,r,o);if(null!==t){const n=t!==L.i.MATERIAL_OPAQUE;n&&(i.hasAlpha=!0),e.useAlphaFromDiffuseTexture=n,e.transparencyMode=t,this.renderMethod===ie.DepthWriteAlphaBlendingWithEvaluation&&(e.forceDepthWrite=n)}}else if(this.renderMethod===ie.DepthWriteAlphaBlendingWithEvaluation){let t=s>>4&3;0==(3^t)&&(t=0),e.transparencyMode=0===t?L.i.MATERIAL_OPAQUE:L.i.MATERIAL_ALPHABLEND}else{let t=15&s;0==(15^t)&&(t=0),e.transparencyMode=L.i.MATERIAL_OPAQUE}};loadSphereTexture=async(e,t,n,r,i,s,a,l,d,h,c)=>{if(n.sphereTextureMode!==M.Material.SphereTextureMode.Off){const u=r[i?.imagePathIndex??-1];if(void 0!==u){const r=s.getEngine().isWebGPU||n.sphereTextureMode===M.Material.SphereTextureMode.Multiply?o.Y.TEXTUREFORMAT_RGBA:o.Y.TEXTUREFORMAT_RGB,g=d.createFullPath(u);let p;const f=d.resolve(g);p=void 0!==f?await this._textureLoader.loadTextureFromBufferAsync(e,g,f instanceof File?f:f.data,s,a,{...i,deleteBuffer:this.deleteTextureBufferAfterLoad,format:r,mimeType:f instanceof File?f.type:f.mimeType}):await this._textureLoader.loadTextureAsync(e,l,u,s,a,{...i,deleteBuffer:this.deleteTextureBufferAfterLoad,format:r}),null!==p?(t.sphereTexture=p,t.sphereTextureBlendMode=n.sphereTextureMode):h.error(`Failed to load sphere texture: ${g}`),c?.()}else c?.()}else c?.()};loadToonTexture=async(e,t,n,r,i,s,a,l,d,h,c)=>{let u;if(u=n.isSharedToonTexture?n.toonTextureIndex:r[i?.imagePathIndex??-1],void 0!==u){const n=d.createFullPath(u.toString());let r;const g="string"==typeof u?d.resolve(n):void 0;r=void 0!==g?await this._textureLoader.loadTextureFromBufferAsync(e,n,g instanceof File?g:g.data,s,a,{...i,deleteBuffer:this.deleteTextureBufferAfterLoad,format:s.getEngine().isWebGPU?o.Y.TEXTUREFORMAT_RGBA:o.Y.TEXTUREFORMAT_RGB,mimeType:g instanceof File?g.type:g.mimeType}):await this._textureLoader.loadTextureAsync(e,l,u,s,a,{...i,deleteBuffer:this.deleteTextureBufferAfterLoad,format:s.getEngine().isWebGPU?o.Y.TEXTUREFORMAT_RGBA:o.Y.TEXTUREFORMAT_RGB}),null!==r?t.toonTexture=r:h.error(`Failed to load toon texture: ${n}`),c?.()}else c?.()};loadOutlineRenderingProperties=(e,t,n)=>{if(t.flag&M.Material.Flag.EnabledToonEdge){void 0===c.Z.prototype.getMmdOutlineRenderer&&n.warn('MMD Outline Renderer is not available. Please import "babylon-mmd/esm/Loader/mmdOutlineRenderer".'),e.renderOutline=!0,e.outlineWidth=t.edgeSize;const r=t.edgeColor;e.outlineColor=new O.v9(r[0],r[1],r[2]),e.outlineAlpha=r[3]}};afterBuildSingleMaterial=()=>{}}class he{lengthComputable;total;_onProgress;_unprocessedTasks;_processingTasks;_endedTaskNames;_endedTasksTotal;constructor(e,t,n){this.lengthComputable=e;let r=0;for(let e=0;e<t.length;++e)r+=t[e].cost;this.total=r,this._onProgress=n;const o=this._unprocessedTasks=new Map;for(let e=0;e<t.length;++e){if(o.has(t[e].name))throw new Error(`Duplicated task name: ${t[e].name}`);o.set(t[e].name,t[e])}this._processingTasks=new Map,this._endedTaskNames=new Set,this._endedTasksTotal=0}_getTaskState(e){let t=this._processingTasks.get(e);if(void 0===t){const n=this._unprocessedTasks.get(e);if(void 0===n){if(this._endedTaskNames.has(e))return null;throw new Error(`Task not found: ${e}`)}t={name:n.name,cost:n.cost,progress:0},this._processingTasks.set(e,t),this._unprocessedTasks.delete(e)}return t}processTask(e,t){const n=this._getTaskState(e);null!==n&&(n.progress+=t,n.progress>=n.cost&&(this._processingTasks.delete(e),this._endedTaskNames.add(e),this._endedTasksTotal+=n.cost))}setTaskProgress(e,t){const n=this._getTaskState(e);return null!==n&&(n.progress=t,n.progress>=n.cost&&(this._processingTasks.delete(e),this._endedTaskNames.add(e),this._endedTasksTotal+=n.cost),!0)}setTaskProgressRatio(e,t,n){const r=this._getTaskState(e);return null!==r&&(r.progress=n?Math.floor(r.cost*t):r.cost*t,r.progress>=r.cost&&(this._processingTasks.delete(e),this._endedTaskNames.add(e),this._endedTasksTotal+=r.cost),!0)}endTask(e){const t=this._getTaskState(e);null!==t&&(this._processingTasks.delete(e),this._endedTaskNames.add(e),this._endedTasksTotal+=t.cost)}invokeProgressEvent(){null!==this._onProgress&&this._onProgress({lengthComputable:this.lengthComputable,loaded:this.loaded,total:this.total})}get loaded(){let e=this._endedTasksTotal;for(const[t,n]of this._processingTasks)e+=n.progress;return e}}class ce{name;extensions;materialBuilder;useSdef;buildSkeleton;buildMorph;boundingBoxMargin;preserveSerializationData;_loggingEnabled;log;warn;error;static _SharedStandardMaterialBuilder=new de;constructor(e,t,n={},r){this.name=e,this.extensions=t,r=r??{materialBuilder:ce._SharedStandardMaterialBuilder,useSdef:!0,buildSkeleton:!0,buildMorph:!0,boundingBoxMargin:10,preserveSerializationData:!1,loggingEnabled:!1},this.materialBuilder=n.materialBuilder??r.materialBuilder,this.useSdef=n.useSdef??r.useSdef,this.buildSkeleton=n.buildSkeleton??r.buildSkeleton,this.buildMorph=n.buildMorph??r.buildMorph,this.boundingBoxMargin=n.boundingBoxMargin??r.boundingBoxMargin,this.preserveSerializationData=n.preserveSerializationData??r.preserveSerializationData,this._loggingEnabled=n.loggingEnabled??r.loggingEnabled,this._loggingEnabled?(this.log=this._logEnabled,this.warn=this._warnEnabled,this.error=this._errorEnabled):(this.log=this._logDisabled,this.warn=this._warnDisabled,this.error=this._errorDisabled)}importMeshAsync(e,t,n,r,o,i){return this._loadAsyncInternal(t,null,n,r,o)}loadAsync(e,t,n,r,o){return this._loadAsyncInternal(e,null,t,n,r).then((()=>{}))}loadAssetContainerAsync(e,t,n,r,o){const i=new R.WZ(e);return this._loadAsyncInternal(e,i,t,n,r).then((()=>i))}async _loadAsyncInternal(e,t,n,r,o){const i=await this._parseFileAsync(n.arrayBuffer),s=new he(!0,this._getProgressTaskCosts(n,i),o??null);s.endTask("Parse"),s.invokeProgressEvent(),e._blockEntityCollection=!!t;const a=new S.e(i.header.modelName,e);a._parentContainer=t,e._blockEntityCollection=!1,a.setEnabled(!1);const l=await this._buildGeometryAsync(n,i,a,e,t,s),d=n.preserveSerializationData?new Map:null,{materials:h,multiMaterials:c,textureLoadPromise:u}=await this._buildMaterialAsync(n,i,a,l.meshes,d,e,t,r,s),g=[];let p=null;n.buildSkeleton?p=await this._buildSkeletonAsync(n,i,l.meshes,e,t,g,s):s.endTask("Build Skeleton");const f=[];let m=null;if(n.buildMorph&&(m=await this._buildMorphAsync(n,i,l,e,t,f,s)),0!==n.boundingBoxMargin&&this._applyBoundingBoxMargin(l.meshes,n.boundingBoxMargin),a.metadata={isMmdModel:!0,header:{modelName:i.header.modelName,englishModelName:i.header.englishModelName,comment:i.header.comment,englishComment:i.header.englishComment},bones:g,morphs:f,rigidBodies:i.rigidBodies,joints:i.joints,meshes:l.meshes,materials:h,skeleton:p},n.preserveSerializationData){const e=[],t=i.materials;for(let n=0;n<t.length;++n){const r=t[n];e.push({englishName:r.englishName,comment:r.comment})}a.metadata={...a.metadata,containsSerializationData:!0,textureNameMap:d,materialsMetadata:e,displayFrames:i.displayFrames}}return s.invokeProgressEvent(),await u,s.endTask("Texture Load"),s.invokeProgressEvent(),a.setEnabled(!0),null!==t&&(t.rootNodes.push(a),t.meshes.push(a,...l.meshes),t.geometries.push(...l.geometries),t.materials.push(...h),t.multiMaterials.push(...c),null!==p&&t.skeletons.push(p),null!==m&&t.morphTargetManagers.push(...m)),{meshes:[a,...l.meshes],particleSystems:[],skeletons:null!==p?[p]:[],animationGroups:[],transformNodes:[],geometries:l.geometries,lights:[],spriteManagers:[]}}_getProgressTaskCosts(e,t){return[{name:"Parse",cost:Math.floor(e.arrayBuffer.byteLength/100)},{name:"Build Material",cost:100*t.materials.length},{name:"Build Skeleton",cost:e.buildSkeleton?100*t.bones.length:0},{name:"Texture Load",cost:3e4*t.textures.length}]}async _buildSkeletonAsync(e,t,n,r,o,i,s){const a=e.preserveSerializationData;r._blockEntityCollection=!!o;const l=new P.E(t.header.modelName,t.header.modelName+"_skeleton",r);l._parentContainer=o,r._blockEntityCollection=!1;{const e=t.bones,n=[],r=[];for(let t=0;t<e.length;++t){const o=e[t];let s=!1;if(0<=o.parentBoneIndex&&o.parentBoneIndex<e.length){let n=o.parentBoneIndex;for(let r=0;r<e.length&&-1!==n;++r){if(n===t){s=!0,this.warn(`Bone loop detected. Ignore Parenting. Bone index: ${t}`);break}n=e[n].parentBoneIndex}t<=o.parentBoneIndex&&this.warn(`Parent bone index is greater equal than child bone index. Bone index: ${t} Parent bone index: ${o.parentBoneIndex}`)}else-1!==o.parentBoneIndex&&this.error(`Parent bone index is out of range. Bone index: ${t} Parent bone index: ${o.parentBoneIndex}`);const d=o.position,c=new h.Pq(d[0],d[1],d[2]);if(0<=o.parentBoneIndex&&o.parentBoneIndex<e.length&&!s){const t=e[o.parentBoneIndex];c.x-=t.position[0],c.y-=t.position[1],c.z-=t.position[2]}const u=h.uq.Identity().setTranslation(c),g=new D.$(o.name,l,void 0,u,void 0,void 0,t);n.push(g),r.push(s);const p={name:o.name,englishName:o.englishName,parentBoneIndex:o.parentBoneIndex,transformOrder:o.transformOrder,flag:o.flag,appendTransform:o.appendTransform,axisLimit:o.axisLimit,ik:o.ik,...a?{tailPosition:o.tailPosition,localVector:o.localVector,externalParentTransform:o.externalParentTransform}:void 0};i.push(p)}for(let t=0;t<n.length;++t){const o=e[t],i=n[t];0<=o.parentBoneIndex&&o.parentBoneIndex<n.length&&!r[t]&&i.setParent(n[o.parentBoneIndex],!1)}for(let e=0;e<n.length;++e){const t=n[e];null===t.getParent()&&t._updateAbsoluteBindMatrices()}}s.endTask("Build Skeleton"),s.invokeProgressEvent();for(let e=0;e<n.length;++e)n[e].skeleton=l;return l}_applyBoundingBoxMargin(e,t){for(let n=0;n<e.length;++n){const r=e[n];if(void 0===r.subMeshes)continue;const o=r.subMeshes;for(let e=0;e<o.length;++e){const n=o[e],r=n.getBoundingInfo();n.setBoundingInfo(new k.j((new h.Pq).setAll(-t).addInPlace(r.minimum),(new h.Pq).setAll(t).addInPlace(r.maximum)))}const i=r.getBoundingInfo();r.setBoundingInfo(new k.j((new h.Pq).setAll(-t).addInPlace(i.minimum),(new h.Pq).setAll(t).addInPlace(i.maximum))),r._updateBoundingInfo()}}get loggingEnabled(){return this._loggingEnabled}set loggingEnabled(e){this._loggingEnabled=e,e?(this.log=this._logEnabled,this.warn=this._warnEnabled,this.error=this._errorEnabled):(this.log=this._logDisabled,this.warn=this._warnDisabled,this.error=this._errorDisabled)}_logEnabled(e){V.V.Log(e)}_logDisabled(){}_warnEnabled(e){V.V.Warn(e)}_warnDisabled(){}_errorEnabled(e){V.V.Error(e)}_errorDisabled(){}}class ue{static _IdMap=new WeakMap;static _NextId=0;constructor(){}static GetId(e){let t=this._IdMap.get(e);return void 0===t&&(t=this._NextId,this._NextId+=1,this._IdMap.set(e,t)),t}}class ge extends S.e{applySkeleton(e){if(!this.geometry)return this;if(this.geometry._softwareSkinningFrameId===this.getScene().getFrameId())return this;if(this.geometry._softwareSkinningFrameId=this.getScene().getFrameId(),!this.isVerticesDataPresent(r.R.PositionKind))return this;if(!this.isVerticesDataPresent(r.R.MatricesIndicesKind))return this;if(!this.isVerticesDataPresent(r.R.MatricesWeightsKind))return this;const t=this.isVerticesDataPresent(r.R.NormalKind),n=this._internalMeshDataInfo;if(!n._sourcePositions){const e=this.subMeshes.slice();this.setPositionsForCPUSkinning(),this.subMeshes=e}t&&!n._sourceNormals&&this.setNormalsForCPUSkinning();let o=this.getVerticesData(r.R.PositionKind);if(!o)return this;o instanceof Float32Array||(o=new Float32Array(o));let i=this.getVerticesData(r.R.NormalKind);if(t){if(!i)return this;i instanceof Float32Array||(i=new Float32Array(i))}const s=this.isVerticesDataPresent(g.V.MatricesSdefCKind);let a=null,l=null,d=null;s&&(a=this.getVerticesData(g.V.MatricesSdefCKind),l=this.getVerticesData(g.V.MatricesSdefRW0Kind),d=this.getVerticesData(g.V.MatricesSdefRW1Kind));const c=this.getVerticesData(r.R.MatricesIndicesKind),u=this.getVerticesData(r.R.MatricesWeightsKind);if(!u||!c)return this;const p=this.numBoneInfluencers>4,f=p?this.getVerticesData(r.R.MatricesIndicesExtraKind):null,m=p?this.getVerticesData(r.R.MatricesWeightsExtraKind):null,x=e.getTransformMatrices(this),y=h.Pq.Zero(),A=new h.uq,T=new h.uq,M=new h.uq,_=new h.uq,b=new h.PT,I=new h.PT,w=new h.Pq,v=n._sourcePositions,E=n._sourceNormals;let S,C=0;for(let e=0;e<o.length;e+=3,C+=4){let n=0;if(s&&(n=l[e]),0===n){let n;for(S=0;S<4;S++)n=u[C+S],n>0&&(h.uq.FromFloat32ArrayToRefScaled(x,Math.floor(16*c[C+S]),n,T),A.addToSelf(T));if(p)for(S=0;S<4;S++)n=m[C+S],n>0&&(h.uq.FromFloat32ArrayToRefScaled(x,Math.floor(16*f[C+S]),n,T),A.addToSelf(T));h.Pq.TransformCoordinatesFromFloatsToRef(v[e],v[e+1],v[e+2],A,y),y.toArray(o,e),t&&(h.Pq.TransformNormalFromFloatsToRef(E[e],E[e+1],E[e+2],A,y),y.toArray(i,e)),A.reset()}else{const n=u[C+0],r=u[C+1];h.uq.FromArrayToRef(x,Math.floor(16*c[C+0]),M),h.uq.FromArrayToRef(x,Math.floor(16*c[C+1]),_),h.PT.FromRotationMatrixToRef(M,b),h.PT.FromRotationMatrixToRef(_,I),h.uq.FromQuaternionToRef(h.PT.SlerpToRef(b,I,r,b),T),h.Pq.TransformCoordinatesFromFloatsToRef(v[e]-a[e],v[e+1]-a[e+1],v[e+2]-a[e+2],T,w),h.Pq.TransformCoordinatesFromFloatsToRef(l[e],l[e+1],l[e+2],M,y).scaleAndAddToRef(n,w),h.Pq.TransformCoordinatesFromFloatsToRef(d[e],d[e+1],d[e+2],_,y).scaleAndAddToRef(r,w),w.toArray(o,e),t&&(h.Pq.TransformNormalFromFloatsToRef(E[e],E[e+1],E[e+2],T,w),w.toArray(i,e))}}return this.updateVerticesData(r.R.PositionKind,o),t&&this.updateVerticesData(r.R.NormalKind,i),this}getClassName(){return"SdefMesh"}clone(e="",t=null,n,r=!0){return new ge(e,this.getScene(),t,this,n,r)}}(0,J.Y5)("BABYLON.SdefMesh",ge);class pe extends ce{referenceFiles;constructor(e,t,n={},r){super(e,t,n,r),this.referenceFiles=n.referenceFiles??r?.referenceFiles??[]}loadFile(e,t,n,r,o,i,s){const a=this.materialBuilder,l=this.useSdef,d=this.buildSkeleton,h=this.buildMorph,c=this.boundingBoxMargin,u=this.referenceFiles,g=this.preserveSerializationData;return e._loadFile(t,((e,n)=>{const o={arrayBuffer:e,pmFileId:t instanceof File?ue.GetId(t).toString():t,materialBuilder:a,useSdef:l,buildSkeleton:d,buildMorph:h,boundingBoxMargin:c,referenceFiles:u,preserveSerializationData:g};r(o,n)}),o,!0,i,s)}_getProgressTaskCosts(e,t){const n=super._getProgressTaskCosts(e,t);if(n.push({name:"Build Geometry",cost:t.indices.length}),e.buildMorph){let e=0;const r=t.morphs;for(let t=0;t<r.length;++t){const n=r[t];n.type!==M.Morph.Type.VertexMorph&&n.type!==M.Morph.Type.UvMorph&&n.type!==M.Morph.Type.AdditionalUvMorph1&&n.type!==M.Morph.Type.AdditionalUvMorph2&&n.type!==M.Morph.Type.AdditionalUvMorph3&&n.type!==M.Morph.Type.AdditionalUvMorph4||(e+=n.indices.length)}n.push({name:"Build Morph",cost:e})}return n}async _buildGeometryAsync(e,t,n,r,o,i){const s=[],a=[];let l;const d=[];{l=t.indices instanceof Uint8Array||t.indices instanceof Uint16Array?new Uint16Array(t.indices.length):new Uint32Array(t.indices.length);{const e=t.indices;for(let t=0;t<l.length;t+=3)l[t+0]=e[t+0],l[t+1]=e[t+2],l[t+2]=e[t+1]}const h=t.materials;let c=0;for(let u=0;u<h.length;++u){const p=h[u],f=new Uint8Array(t.vertices.length);let m=0;{const e=p.indexCount;for(let t=0;t<e;++t){const e=l[c+t];0===f[e]&&(f[e]=1,m+=1)}f.fill(0)}const x=new C.P,y=[];if(e.preserveSerializationData)for(let e=0;e<t.header.additionalVec4Count;++e)y.push(new Float32Array(4*m));let A=null,T=null,_=null,b=null,I=null;e.buildSkeleton&&e.useSdef&&(A=new Float32Array(3*m),T=new Float32Array(3*m),_=new Float32Array(3*m),b=new Float32Array(3*m),I=new Float32Array(3*m));let w=!1,v=null;e.preserveSerializationData&&(v=new Float32Array(m));const B=new t.indices.constructor(t.vertices.length);{const n=new Float32Array(3*m),r=new Float32Array(3*m),o=new Float32Array(2*m),s=new l.constructor(p.indexCount);let a=null,d=null;e.buildSkeleton&&(a=new Float32Array(4*m),d=new Float32Array(4*m));let h=performance.now(),u=0,g=0;const E=p.indexCount;for(let p=0;p<E;++p){const m=l[c+p];if(0===f[m]){f[m]=1;const i=t.vertices[m];n[3*u+0]=i.position[0],n[3*u+1]=i.position[1],n[3*u+2]=i.position[2],r[3*u+0]=i.normal[0],r[3*u+1]=i.normal[1],r[3*u+2]=i.normal[2],o[2*u+0]=i.uv[0],o[2*u+1]=1-i.uv[1];const l=i.additionalVec4;for(let e=0;e<y.length;++e)y[e][4*u+0]=l[e][0],y[e][4*u+1]=l[e][1],y[e][4*u+2]=l[e][2],y[e][4*u+3]=l[e][3];if(e.buildSkeleton)switch(i.weightType){case M.Vertex.BoneWeightType.Bdef1:{const e=i.boneWeight;a[4*u+0]=e.boneIndices,a[4*u+1]=0,a[4*u+2]=0,a[4*u+3]=0,d[4*u+0]=1,d[4*u+1]=0,d[4*u+2]=0,d[4*u+3]=0}break;case M.Vertex.BoneWeightType.Bdef2:{const e=i.boneWeight;a[4*u+0]=e.boneIndices[0],a[4*u+1]=e.boneIndices[1],a[4*u+2]=0,a[4*u+3]=0,d[4*u+0]=e.boneWeights,d[4*u+1]=1-e.boneWeights,d[4*u+2]=0,d[4*u+3]=0}break;case M.Vertex.BoneWeightType.Bdef4:case M.Vertex.BoneWeightType.Qdef:{const e=i.boneWeight;a[4*u+0]=e.boneIndices[0],a[4*u+1]=e.boneIndices[1],a[4*u+2]=e.boneIndices[2],a[4*u+3]=e.boneIndices[3],d[4*u+0]=e.boneWeights[0],d[4*u+1]=e.boneWeights[1],d[4*u+2]=e.boneWeights[2],d[4*u+3]=e.boneWeights[3]}break;case M.Vertex.BoneWeightType.Sdef:{const t=i.boneWeight;a[4*u+0]=t.boneIndices[0],a[4*u+1]=t.boneIndices[1],a[4*u+2]=0,a[4*u+3]=0;const n=t.boneWeights,r=n.boneWeight0,o=1-r;if(d[4*u+0]=r,d[4*u+1]=o,d[4*u+2]=0,d[4*u+3]=0,e.useSdef){const e=n.c[0],t=n.c[1],i=n.c[2];let s=n.r0[0],a=n.r0[1],l=n.r0[2],d=n.r1[0],h=n.r1[1],c=n.r1[2];T[3*u+0]=s,T[3*u+1]=a,T[3*u+2]=l,_[3*u+0]=d,_[3*u+1]=h,_[3*u+2]=c;const g=s*r+d*o,p=a*r+h*o,f=l*r+c*o;s=e+s-g,a=t+a-p,l=i+l-f,d=e+d-g,h=t+h-p,c=i+c-f;const m=.5*(e+s),x=.5*(t+a),y=.5*(i+l),M=.5*(e+d),v=.5*(t+h),E=.5*(i+c);A[3*u+0]=e,A[3*u+1]=t,A[3*u+2]=i,b[3*u+0]=m,b[3*u+1]=x,b[3*u+2]=y,I[3*u+0]=M,I[3*u+1]=v,I[3*u+2]=E,w=!0}}}e.preserveSerializationData&&(v[u]=i.edgeScale),s[g]=u,B[m]=u,g+=1,u+=1}else s[g]=B[m],g+=1;(c+p)%1e4==0&&100<performance.now()-h&&(i.setTaskProgress("Build Geometry",c+p),i.invokeProgressEvent(),await F.S0.DelayAsync(0),h=performance.now())}x.positions=n,x.normals=r,x.uvs=o,x.indices=s,x.matricesIndices=a,x.matricesWeights=d}r._blockEntityCollection=!!o;const U=new(e.useSdef&&w?ge:S.e)(p.name,r);U._parentContainer=o,r._blockEntityCollection=!1,U.setParent(n),s.push(U),r._blockEntityCollection=!!o;const R=new E.V(t.header.modelName,r,x,!1);R._parentContainer=o,r._blockEntityCollection=!1,e.preserveSerializationData&&(1<=y.length&&R.setVerticesData(g.V.AdditionalUV1Kind,y[0],!1,4),2<=y.length&&R.setVerticesData(g.V.AdditionalUV2Kind,y[1],!1,4),3<=y.length&&R.setVerticesData(g.V.AdditionalUV3Kind,y[2],!1,4),4<=y.length&&R.setVerticesData(g.V.AdditionalUV4Kind,y[3],!1,4)),e.useSdef&&w&&(R.setVerticesData(g.V.MatricesSdefCKind,A,!1,3),R.setVerticesData(g.V.MatricesSdefR0Kind,T,!1,3),R.setVerticesData(g.V.MatricesSdefR1Kind,_,!1,3),R.setVerticesData(g.V.MatricesSdefRW0Kind,b,!1,3),R.setVerticesData(g.V.MatricesSdefRW1Kind,I,!1,3)),e.preserveSerializationData&&R.setVerticesData(g.V.EdgeScaleKind,v,!1,1),R.applyToMesh(U),a.push(R),d.push({map:B,isReferencedVertex:f}),c+=p.indexCount}}return i.endTask("Build Geometry"),i.invokeProgressEvent(),{meshes:s,geometries:a,indices:l,indexToSubmehIndexMaps:d}}async _buildMaterialAsync(e,t,n,r,o,i,s,a,l){let d;const h=new Array(t.textures.length);for(let e=0;e<h.length;++e)h[e]={noMipmap:!1,invertY:!0,samplingMode:void 0,imagePathIndex:e};const c=[];for(let e=0;e<r.length;++e)c.push([r[e]]);const u=new Promise((u=>{d=e.materialBuilder.buildMaterials(n.uniqueId,t.materials,h,t.textures,a,"file:"+e.pmFileId+"_",e.referenceFiles,c,r,i,s,o,this,(e=>{e.lengthComputable&&(l.setTaskProgressRatio("Texture Load",e.loaded/e.total,!0),l.invokeProgressEvent())}),(()=>u()))})),g=Array.isArray(d)?d:await d;for(let e=0;e<g.length;++e)r[e].material=g[e];return l.endTask("Build Material"),l.invokeProgressEvent(),{materials:g,multiMaterials:[],textureLoadPromise:u}}async _buildMorphAsync(e,t,n,o,i,s,a){const l=e.preserveSerializationData,d=new Int32Array(t.vertices.length).fill(-1),h=new Map,c=n.indices;{const e=t.materials;let n=0;for(let t=0;t<e.length;++t){const r=e[t].indexCount;for(let e=0;e<r;++e){const r=c[n+e];if(-1===d[r])d[r]=t;else if(-2===d[r]){const e=h.get(r);e.includes(t)||e.push(t)}else d[r]!==t&&(h.set(r,[d[r],t]),d[r]=-2)}n+=r}}const u=n.indexToSubmehIndexMaps,g=t.morphs,p=n.geometries,f=new Array(p.length);for(let e=0;e<f.length;++e)f[e]=[];let m=0,x=performance.now();for(let e=0;e<g.length;++e){const t=g[e],n=[],i=[];switch(t.type){case M.Morph.Type.GroupMorph:case M.Morph.Type.BoneMorph:case M.Morph.Type.MaterialMorph:s.push(t);break;case M.Morph.Type.VertexMorph:case M.Morph.Type.UvMorph:case M.Morph.Type.AdditionalUvMorph1:case M.Morph.Type.AdditionalUvMorph2:case M.Morph.Type.AdditionalUvMorph3:case M.Morph.Type.AdditionalUvMorph4:s.push({name:t.name,englishName:t.englishName,category:t.category,type:t.type,morphTargets:n,...l?{elements:i}:void 0});break;default:this.warn(`Unsupported morph type: ${t.type}`)}if(t.type!==M.Morph.Type.VertexMorph&&t.type!==M.Morph.Type.UvMorph&&t.type!==M.Morph.Type.AdditionalUvMorph1&&t.type!==M.Morph.Type.AdditionalUvMorph2&&t.type!==M.Morph.Type.AdditionalUvMorph3&&t.type!==M.Morph.Type.AdditionalUvMorph4)continue;const c=[];{const e=t.indices;for(let t=0;t<e.length;++t){const n=e[t],r=d[n];if(-1!==r)if(-2===r){const e=h.get(n);for(let t=0;t<e.length;++t){const n=e[t];c.includes(n)||c.push(n)}}else c.includes(r)||c.push(r)}if(t.type!==M.Morph.Type.AdditionalUvMorph1&&t.type!==M.Morph.Type.AdditionalUvMorph2&&t.type!==M.Morph.Type.AdditionalUvMorph3&&t.type!==M.Morph.Type.AdditionalUvMorph4)for(let e=0;e<c.length;++e){const r=new B.M(t.name,0,o);n.push(r),f[c[e]].push(r)}}if(t.type===M.Morph.Type.VertexMorph)for(let e=0;e<c.length;++e){const o=c[e],s=p[o],a=new Float32Array(s.getVerticesData(r.R.PositionKind)),d=t.indices,h=t.positions,g=u[o].map,f=u[o].isReferencedVertex;if(l){let e=0;for(let t=0;t<d.length;++t){if(0===f[d[t]])continue;const n=g[d[t]];a[3*n+0]+=h[3*t+0],a[3*n+1]+=h[3*t+1],a[3*n+2]+=h[3*t+2],e+=1}const t=new Int32Array(e),n=new Float32Array(3*e);for(let e=0,r=0;e<d.length;++e){if(0===f[d[e]])continue;const o=g[d[e]];t[r]=o,n[3*r+0]=h[3*e+0],n[3*r+1]=h[3*e+1],n[3*r+2]=h[3*e+2],r+=1}i.push({meshIndex:o,indices:t,offsets:n})}else for(let e=0;e<d.length;++e){if(0===f[d[e]])continue;const t=g[d[e]];a[3*t+0]+=h[3*e+0],a[3*t+1]+=h[3*e+1],a[3*t+2]+=h[3*e+2]}n[e].setPositions(a)}else if(t.type===M.Morph.Type.UvMorph)for(let e=0;e<c.length;++e){const o=c[e],s=p[o],a=new Float32Array(s.getVerticesData(r.R.UVKind)),d=t.indices,h=t.offsets,g=u[o].map,f=u[o].isReferencedVertex;if(l){let e=0;for(let t=0;t<d.length;++t){if(0===f[d[t]])continue;const n=g[d[t]];a[2*n+0]+=h[4*t+0],a[2*n+1]-=h[4*t+1],e+=1}const t=new Int32Array(e),n=new Float32Array(4*e);for(let e=0,r=0;e<d.length;++e){if(0===f[d[e]])continue;const o=g[d[e]];t[r]=o,n[4*r+0]=h[4*e+0],n[4*r+1]=-h[4*e+1],n[4*r+2]=h[4*e+2],n[4*r+3]=h[4*e+3],r+=1}i.push({meshIndex:o,indices:t,offsets:n})}else for(let e=0;e<d.length;++e){if(0===f[d[e]])continue;const t=g[d[e]];a[2*t+0]+=h[4*e+0],a[2*t+1]-=h[4*e+1]}const m=n[e];m.setPositions(s.getVerticesData(r.R.PositionKind)),m.setUVs(a)}else if(l)for(let e=0;e<c.length;++e){const n=c[e],r=u[n].map,o=u[n].isReferencedVertex,s=t.indices,a=t.offsets;let l=0;for(let e=0;e<s.length;++e)0!==o[s[e]]&&(l+=1);const d=new Int32Array(l),h=new Float32Array(4*l);for(let e=0,t=0;e<s.length;++e){if(0===o[s[e]])continue;const n=r[s[e]];d[t]=n,h[4*t+0]=a[4*e+0],h[4*t+1]=a[4*e+1],h[4*t+2]=a[4*e+2],h[4*t+3]=a[4*e+3],t+=1}i.push({meshIndex:n,indices:d,offsets:h})}m+=t.indices.length,100<performance.now()-x&&(a.setTaskProgress("Build Morph",m),a.invokeProgressEvent(),await F.S0.DelayAsync(0),x=performance.now())}a.endTask("Build Morph");const y=[],A=n.meshes;for(let e=0;e<f.length;++e){const t=f[e];if(0===t.length)continue;o._blockEntityCollection=!!i;const n=new U.j(o);n._parentContainer=i,o._blockEntityCollection=!1,n.enableNormalMorphing=!1,n.enableTangentMorphing=!1,n.enableUVMorphing=!1,n.areUpdatesFrozen=!0;for(let e=0;e<t.length;++e){const r=t[e];n.addTarget(r),r.hasUVs&&(n.enableUVMorphing=!0)}if(n.enableUVMorphing){const n=p[e].getVerticesData(r.R.UVKind);for(let e=0;e<t.length;++e){const r=t[e];r.hasUVs||r.setUVs(n)}}n.areUpdatesFrozen=!1,y.push(n),A[e].morphTargetManager=n}return y}}class fe extends pe{constructor(e,t){super("pmd",v,e,t)}createPlugin(e){return new fe(e.mmdmodel,this)}async _parseFileAsync(e){return await w.ParseAsync(e,this).catch((e=>Promise.reject(e)))}}(0,_.cH)(new fe);class me{_vertexIndexSize;_textureIndexSize;_materialIndexSize;_boneIndexSize;_morphIndexSize;_rigidBodyIndexSize;constructor(e,t,n,r,o,i){this._vertexIndexSize=e,this._textureIndexSize=t,this._materialIndexSize=n,this._boneIndexSize=r,this._morphIndexSize=o,this._rigidBodyIndexSize=i}getVertexIndex(e){switch(this._vertexIndexSize){case 1:return e.getUint8();case 2:return e.getUint16();case 4:return e.getInt32();default:throw new Error(`Invalid vertexIndexSize: ${this._vertexIndexSize}`)}}_getNonVertexIndex(e,t){switch(t){case 1:return e.getInt8();case 2:return e.getInt16();case 4:return e.getInt32();default:throw new Error(`Invalid indexSize: ${t}`)}}getTextureIndex(e){return this._getNonVertexIndex(e,this._textureIndexSize)}getMaterialIndex(e){return this._getNonVertexIndex(e,this._materialIndexSize)}getBoneIndex(e){return this._getNonVertexIndex(e,this._boneIndexSize)}getMorphIndex(e){return this._getNonVertexIndex(e,this._morphIndexSize)}getRigidBodyIndex(e){return this._getNonVertexIndex(e,this._rigidBodyIndexSize)}}class xe{constructor(){}static async ParseAsync(e,t=new b){const n=new I(e),r=this._ParseHeader(n,t),o=new me(r.vertexIndexSize,r.textureIndexSize,r.materialIndexSize,r.boneIndexSize,r.morphIndexSize,r.rigidBodyIndexSize),i=await this._ParseVerticesAsync(n,o,r),s=this._ParseIndices(n,o,r),a=this._ParseTextures(n),l=this._ParseMaterials(n,o),d=this._ParseBones(n,o),h=this._ParseMorphs(n,o),c=this._ParseDisplayFrames(n,o),u=this._ParseRigidBodies(n,o),g=this._ParseJoints(n,o),p=r.version<=2?[]:this._ParseSoftBodies(n,o,r);return n.bytesAvailable>0&&t.warn(`There are ${n.bytesAvailable} bytes left after parsing`),{header:r,vertices:i,indices:s,textures:a,materials:l,bones:d,morphs:h,displayFrames:c,rigidBodies:u,joints:g,softBodies:p}}static _ParseHeader(e,t){if(e.bytesAvailable<17)throw new RangeError("is not pmx file");const n=e.getSignatureString(3);if("PMX"!==n)throw new RangeError("is not pmx file");e.getInt8();const r=e.getFloat32(),o=e.getUint8(),i=e.getUint8();e.initializeTextDecoder(i===M.Header.Encoding.Utf8?"utf-8":"utf-16le");const s=e.getUint8(),a=e.getUint8(),l=e.getUint8(),d=e.getUint8(),h=e.getUint8(),c=e.getUint8(),u=e.getUint8();if(o<8)throw new Error(`Invalid globalsCount: ${o}`);if(8<o){t.warn(`globalsCount is greater than 8: ${o} files may be corrupted or higher version`);for(let t=8;t<o;++t)e.getUint8()}return{signature:n,version:r,encoding:i,additionalVec4Count:s,vertexIndexSize:a,textureIndexSize:l,materialIndexSize:d,boneIndexSize:h,morphIndexSize:c,rigidBodyIndexSize:u,modelName:e.getDecoderString(e.getInt32(),!1),englishModelName:e.getDecoderString(e.getInt32(),!1),comment:e.getDecoderString(e.getInt32(),!1),englishComment:e.getDecoderString(e.getInt32(),!1)}}static async _ParseVerticesAsync(e,t,n){const r=e.getInt32(),o=[];let i=performance.now();for(let s=0;s<r;++s){const r=e.getFloat32Tuple(3),a=e.getFloat32Tuple(3),l=e.getFloat32Tuple(2),d=[];for(let t=0;t<n.additionalVec4Count;++t)d.push(e.getFloat32Tuple(4));const h=e.getUint8();let c;switch(h){case M.Vertex.BoneWeightType.Bdef1:c={boneIndices:t.getBoneIndex(e),boneWeights:null};break;case M.Vertex.BoneWeightType.Bdef2:c={boneIndices:[t.getBoneIndex(e),t.getBoneIndex(e)],boneWeights:e.getFloat32()};break;case M.Vertex.BoneWeightType.Bdef4:c={boneIndices:[t.getBoneIndex(e),t.getBoneIndex(e),t.getBoneIndex(e),t.getBoneIndex(e)],boneWeights:[e.getFloat32(),e.getFloat32(),e.getFloat32(),e.getFloat32()]};break;case M.Vertex.BoneWeightType.Sdef:c={boneIndices:[t.getBoneIndex(e),t.getBoneIndex(e)],boneWeights:{boneWeight0:e.getFloat32(),c:e.getFloat32Tuple(3),r0:e.getFloat32Tuple(3),r1:e.getFloat32Tuple(3)}};break;case M.Vertex.BoneWeightType.Qdef:c={boneIndices:[t.getBoneIndex(e),t.getBoneIndex(e),t.getBoneIndex(e),t.getBoneIndex(e)],boneWeights:[e.getFloat32(),e.getFloat32(),e.getFloat32(),e.getFloat32()]};break;default:throw new Error(`Invalid weightType: ${h}`)}const u=e.getFloat32();o.push({position:r,normal:a,uv:l,additionalVec4:d,weightType:h,boneWeight:c,edgeScale:u}),s%1e4==0&&100<performance.now()-i&&(await new Promise((e=>setTimeout(e,0))),i=performance.now())}return o}static _ParseIndices(e,t,n){const r=e.getInt32(),o=new ArrayBuffer(r*n.vertexIndexSize);let i;switch(n.vertexIndexSize){case 1:i=new Uint8Array(o);break;case 2:i=new Uint16Array(o);break;case 4:i=new Int32Array(o);break;default:throw new Error(`Invalid vertexIndexSize: ${n.vertexIndexSize}`)}for(let n=0;n<r;++n)i[n]=t.getVertexIndex(e);return i}static _ParseTextures(e){const t=e.getInt32(),n=[];for(let r=0;r<t;++r){const t=e.getDecoderString(e.getInt32(),!1);n.push(t)}return n}static _ParseMaterials(e,t){const n=e.getInt32(),r=[];for(let o=0;o<n;++o){const n=e.getDecoderString(e.getInt32(),!1),o=e.getDecoderString(e.getInt32(),!1),i=e.getFloat32Tuple(4),s=e.getFloat32Tuple(3),a=e.getFloat32(),l=e.getFloat32Tuple(3),d=e.getUint8(),h=e.getFloat32Tuple(4),c=e.getFloat32(),u=t.getTextureIndex(e),g=t.getTextureIndex(e),p=e.getUint8(),f=1===e.getUint8(),m={name:n,englishName:o,diffuse:i,specular:s,shininess:a,ambient:l,flag:d,edgeColor:h,edgeSize:c,textureIndex:u,sphereTextureIndex:g,sphereTextureMode:p,isSharedToonTexture:f,toonTextureIndex:f?e.getUint8():t.getTextureIndex(e),comment:e.getDecoderString(e.getInt32(),!1),indexCount:e.getInt32()};r.push(m)}return r}static _ParseBones(e,t){const n=e.getInt32(),r=[];for(let o=0;o<n;++o){const n=e.getDecoderString(e.getInt32(),!1),o=e.getDecoderString(e.getInt32(),!1),i=e.getFloat32Tuple(3),s=t.getBoneIndex(e),a=e.getInt32(),l=e.getUint16();let d,h,c,u,g,p;if(d=l&M.Bone.Flag.UseBoneIndexAsTailPosition?t.getBoneIndex(e):e.getFloat32Tuple(3),(l&M.Bone.Flag.HasAppendMove||l&M.Bone.Flag.HasAppendRotate)&&(h={parentIndex:t.getBoneIndex(e),ratio:e.getFloat32()}),l&M.Bone.Flag.HasAxisLimit&&(c=e.getFloat32Tuple(3)),l&M.Bone.Flag.HasLocalVector&&(u={x:e.getFloat32Tuple(3),z:e.getFloat32Tuple(3)}),l&M.Bone.Flag.IsExternalParentTransformed&&(g=e.getInt32()),l&M.Bone.Flag.IsIkEnabled){const n=t.getBoneIndex(e),r=e.getInt32(),o=e.getFloat32(),i=[],s=e.getInt32();for(let n=0;n<s;++n){const n={target:t.getBoneIndex(e),limitation:1===e.getUint8()?{minimumAngle:e.getFloat32Tuple(3),maximumAngle:e.getFloat32Tuple(3)}:void 0};i.push(n)}p={target:n,iteration:r,rotationConstraint:o,links:i}}const f={name:n,englishName:o,position:i,parentBoneIndex:s,transformOrder:a,flag:l,tailPosition:d,appendTransform:h,axisLimit:c,localVector:u,externalParentTransform:g,ik:p};r.push(f)}return r}static _ParseMorphs(e,t){const n=e.getInt32(),r=[];for(let o=0;o<n;++o){const n=e.getDecoderString(e.getInt32(),!1),o=e.getDecoderString(e.getInt32(),!1),i=e.getInt8(),s=e.getInt8();let a={name:n,englishName:o,category:i,type:s};const l=e.getInt32();switch(s){case M.Morph.Type.GroupMorph:{const n=new Int32Array(l),r=new Float32Array(l);for(let o=0;o<l;++o)n[o]=t.getMorphIndex(e),r[o]=e.getFloat32();a={...a,indices:n,ratios:r}}break;case M.Morph.Type.VertexMorph:{const n=new Int32Array(l),r=new Float32Array(3*l);for(let o=0;o<l;++o)n[o]=t.getVertexIndex(e),r[3*o+0]=e.getFloat32(),r[3*o+1]=e.getFloat32(),r[3*o+2]=e.getFloat32();a={...a,indices:n,positions:r}}break;case M.Morph.Type.BoneMorph:{const n=new Int32Array(l),r=new Float32Array(3*l),o=new Float32Array(4*l);for(let i=0;i<l;++i)n[i]=t.getBoneIndex(e),r[3*i+0]=e.getFloat32(),r[3*i+1]=e.getFloat32(),r[3*i+2]=e.getFloat32(),o[4*i+0]=e.getFloat32(),o[4*i+1]=e.getFloat32(),o[4*i+2]=e.getFloat32(),o[4*i+3]=e.getFloat32();a={...a,indices:n,positions:r,rotations:o}}break;case M.Morph.Type.UvMorph:case M.Morph.Type.AdditionalUvMorph1:case M.Morph.Type.AdditionalUvMorph2:case M.Morph.Type.AdditionalUvMorph3:case M.Morph.Type.AdditionalUvMorph4:{const n=new Int32Array(l),r=new Float32Array(4*l);for(let o=0;o<l;++o)n[o]=t.getVertexIndex(e),r[4*o+0]=e.getFloat32(),r[4*o+1]=e.getFloat32(),r[4*o+2]=e.getFloat32(),r[4*o+3]=e.getFloat32();a={...a,indices:n,offsets:r}}break;case M.Morph.Type.MaterialMorph:{const n=[];for(let r=0;r<l;++r){const r={index:t.getMaterialIndex(e),type:e.getUint8(),diffuse:e.getFloat32Tuple(4),specular:e.getFloat32Tuple(3),shininess:e.getFloat32(),ambient:e.getFloat32Tuple(3),edgeColor:e.getFloat32Tuple(4),edgeSize:e.getFloat32(),textureColor:e.getFloat32Tuple(4),sphereTextureColor:e.getFloat32Tuple(4),toonTextureColor:e.getFloat32Tuple(4)};n.push(r)}a={...a,elements:n}}break;case M.Morph.Type.FlipMorph:{const n=new Int32Array(l),r=new Float32Array(l);for(let o=0;o<l;++o)n[o]=t.getMorphIndex(e),r[o]=e.getFloat32();a={...a,indices:n,ratios:r}}break;case M.Morph.Type.ImpulseMorph:{const n=new Int32Array(l),r=new Array(l),o=new Float32Array(3*l),i=new Float32Array(3*l);for(let s=0;s<l;++s)n[s]=t.getRigidBodyIndex(e),r[s]=1===e.getUint8(),o[3*s+0]=e.getFloat32(),o[3*s+1]=e.getFloat32(),o[3*s+2]=e.getFloat32(),i[3*s+0]=e.getFloat32(),i[3*s+1]=e.getFloat32(),i[3*s+2]=e.getFloat32();a={...a,indices:n,isLocals:r,velocities:o,torques:i}}break;default:throw new Error(`Unknown morph type: ${s}`)}r.push(a)}return r}static _ParseDisplayFrames(e,t){const n=e.getInt32(),r=[];for(let o=0;o<n;++o){const n=e.getDecoderString(e.getInt32(),!1),o=e.getDecoderString(e.getInt32(),!1),i=1===e.getUint8(),s=e.getInt32(),a=[];for(let n=0;n<s;++n){const n=e.getUint8(),r={type:n,index:n===M.DisplayFrame.FrameData.FrameType.Bone?t.getBoneIndex(e):t.getMorphIndex(e)};a.push(r)}const l={name:n,englishName:o,isSpecialFrame:i,frames:a};r.push(l)}return r}static _ParseRigidBodies(e,t){const n=e.getInt32(),r=[];for(let o=0;o<n;++o){const n={name:e.getDecoderString(e.getInt32(),!1),englishName:e.getDecoderString(e.getInt32(),!1),boneIndex:t.getBoneIndex(e),collisionGroup:e.getUint8(),collisionMask:e.getUint16(),shapeType:e.getUint8(),shapeSize:e.getFloat32Tuple(3),shapePosition:e.getFloat32Tuple(3),shapeRotation:e.getFloat32Tuple(3),mass:e.getFloat32(),linearDamping:e.getFloat32(),angularDamping:e.getFloat32(),repulsion:e.getFloat32(),friction:e.getFloat32(),physicsMode:e.getUint8()};r.push(n)}return r}static _ParseJoints(e,t){const n=e.getInt32(),r=[];for(let o=0;o<n;++o){const n={name:e.getDecoderString(e.getInt32(),!1),englishName:e.getDecoderString(e.getInt32(),!1),type:e.getUint8(),rigidbodyIndexA:t.getRigidBodyIndex(e),rigidbodyIndexB:t.getRigidBodyIndex(e),position:e.getFloat32Tuple(3),rotation:e.getFloat32Tuple(3),positionMin:e.getFloat32Tuple(3),positionMax:e.getFloat32Tuple(3),rotationMin:e.getFloat32Tuple(3),rotationMax:e.getFloat32Tuple(3),springPosition:e.getFloat32Tuple(3),springRotation:e.getFloat32Tuple(3)};r.push(n)}return r}static _ParseSoftBodies(e,t,n){const r=e.getInt32(),o=[];for(let i=0;i<r;++i){const r=e.getDecoderString(e.getInt32(),!1),i=e.getDecoderString(e.getInt32(),!1),s=e.getUint8(),a=t.getMaterialIndex(e),l=e.getUint8(),d=e.getUint16(),h=e.getUint8(),c=e.getInt32(),u=e.getInt32(),g=e.getFloat32(),p=e.getFloat32(),f=e.getInt32(),m={vcf:e.getFloat32(),dp:e.getFloat32(),dg:e.getFloat32(),lf:e.getFloat32(),pr:e.getFloat32(),vc:e.getFloat32(),df:e.getFloat32(),mt:e.getFloat32(),chr:e.getFloat32(),khr:e.getFloat32(),shr:e.getFloat32(),ahr:e.getFloat32()},x={srhrCl:e.getFloat32(),skhrCl:e.getFloat32(),sshrCl:e.getFloat32(),srSpltCl:e.getFloat32(),skSpltCl:e.getFloat32(),ssSpltCl:e.getFloat32()},y={vIt:e.getInt32(),pIt:e.getInt32(),dIt:e.getInt32(),cIt:e.getInt32()},A={lst:e.getInt32(),ast:e.getInt32(),vst:e.getInt32()},T=e.getInt32(),M=[];for(let n=0;n<T;++n){const n={rigidbodyIndex:t.getRigidBodyIndex(e),vertexIndex:t.getVertexIndex(e),isNearMode:0!==e.getUint8()};M.push(n)}const _=e.getInt32(),b=new ArrayBuffer(_*n.vertexIndexSize);let I;switch(n.vertexIndexSize){case 1:I=new Uint8Array(b);break;case 2:I=new Uint16Array(b);break;case 4:I=new Int32Array(b);break;default:throw new Error(`Invalid vertexIndexSize: ${n.vertexIndexSize}`)}for(let n=0;n<_;++n)I[n]=t.getVertexIndex(e);const w={name:r,englishName:i,type:s,materialIndex:a,collisionGroup:l,collisionMask:d,flags:h,bLinkDistance:c,clusterCount:u,totalMass:g,collisionMargin:p,aeroModel:f,config:m,cluster:x,iteration:y,material:A,anchors:M,vertexPins:I};o.push(w)}return o}}const ye={".pmx":{isBinary:!0}};class Ae extends pe{constructor(e,t){super("pmx",ye,e,t)}createPlugin(e){return new Ae(e.mmdmodel,this)}async _parseFileAsync(e){return await xe.ParseAsync(e,this).catch((e=>Promise.reject(e)))}}(0,_.cH)(new Ae);var Te,Me,_e,be=n(9057),Ie=n(5581),we=n(1513),ve=n(8595),Ee=n(8529),Se=n(957);!function(e){e.isMmdMesh=function(e){return!(null===e.metadata||!e.metadata.isMmdModel)},e.isMmdSkinnedMesh=function(e){return!(null===e.metadata||!e.metadata.isMmdModel)&&null!==e.metadata.skeleton}}(Te||(Te={})),function(e){e.isSerializationMetadata=function(e){return!0===e.containsSerializationData}}(Me||(Me={}));class Ce{_dataView;_encoder;_offset;constructor(e){this._dataView=new DataView(e),this._encoder=new TextEncoder,this._offset=0}get offset(){return this._offset}set offset(e){this._offset=e}setUint8(e){this._dataView.setUint8(this._offset,e),this._offset+=1}setUint8Array(e){const t=this._dataView;for(let n=0;n<e.length;++n)t.setUint8(this._offset,e[n]),this._offset+=1}setInt8(e){this._dataView.setInt8(this._offset,e),this._offset+=1}setInt8Array(e){const t=this._dataView;for(let n=0;n<e.length;++n)t.setInt8(this._offset,e[n]),this._offset+=1}setUint16(e){this._dataView.setUint16(this._offset,e,!0),this._offset+=2}setUint16Array(e){const t=this._dataView;for(let n=0;n<e.length;++n)t.setUint16(this._offset,e[n],!0),this._offset+=2}setUint32(e){this._dataView.setUint32(this._offset,e,!0),this._offset+=4}setUint32Array(e){const t=this._dataView;for(let n=0;n<e.length;++n)t.setUint32(this._offset,e[n],!0),this._offset+=4}setInt32(e){this._dataView.setInt32(this._offset,e,!0),this._offset+=4}setInt32Array(e){const t=this._dataView;for(let n=0;n<e.length;++n)t.setInt32(this._offset,e[n],!0),this._offset+=4}setFloat32(e){this._dataView.setFloat32(this._offset,e,!0),this._offset+=4}setFloat32Array(e){const t=this._dataView;for(let n=0;n<e.length;++n)t.setFloat32(this._offset,e[n],!0),this._offset+=4}setString(e){const t=this._dataView,n=this._encoder.encode(e);t.setUint32(this._offset,n.length,!0),this._offset+=4;for(let e=0;e<n.length;++e)t.setUint8(this._offset,n[e]),this._offset+=1}get bytesAvailable(){return this._dataView.byteLength-this._offset}static Padding(e,t){return e%t==0?0:t-e%t}}!function(e){let t,n,r;!function(e){let t,n,r;!function(e){e[e.IsSkinnedMesh=1]="IsSkinnedMesh"}(t=e.MeshType||(e.MeshType={})),function(e){e[e.HasSdef=1]="HasSdef",e[e.IsIndexed=2]="IsIndexed",e[e.HasEdgeScale=4]="HasEdgeScale"}(n=e.GeometryType||(e.GeometryType={})),function(e){e[e.Int32=0]="Int32",e[e.Uint32=1]="Uint32",e[e.Uint16=2]="Uint16"}(r=e.IndexElementType||(e.IndexElementType={}))}(t=e.Geometry||(e.Geometry={})),function(e){let t;!function(e){e[e.HasMimeType=1]="HasMimeType"}(t=e.Flag||(e.Flag={}))}(n=e.Image||(e.Image={})),function(e){let t;!function(e){e[e.NoMipmap=1]="NoMipmap",e[e.InvertY=2]="InvertY"}(t=e.Flag||(e.Flag={}))}(r=e.Texture||(e.Texture={}))}(_e||(_e={}));class Fe{_loggingEnabled;log;warn;error;constructor(){this._loggingEnabled=!0,this.log=this._logDisabled,this.warn=this._warnDisabled,this.error=this._errorDisabled}convert(e,t={}){if(!Te.isMmdMesh(e))throw new Error(`${e.name} is not MmdMesh`);const{includeSkinningData:n=!0,includeMorphData:o=!0,translucentMaterials:i=[],alphaEvaluateResults:s=[]}=t,a=e.metadata,l=Me.isSerializationMetadata(a);n&&null===a.skeleton&&this.log("MmdMesh has no skeleton. Skinning data will not be included");const d=[],h=new Int32Array(a.bones.length).fill(-1);let c=-1;const u=a.skeleton?.bones??[];for(let e=0;e<u.length;++e)c=Math.max(c,u[e].getIndex());const p=new Int32Array(c+1).fill(-1);if(n&&null!==a.skeleton){const e=a.bones,t=new Map;{const n=new Map;for(let e=0;e<u.length;++e){const t=u[e];let r=n.get(t.name);void 0===r&&(r=[],n.set(t.name,r)),r.push({index:e,value:t})}for(let r=0;r<e.length;++r){const o=e[r],i=n.get(o.name);if(void 0!==i)if(1===i.length)t.set(o,i[0].value);else{let e;for(let t=0;t<i.length;++t)if(i[t].index===r){e=i[t].value;break}void 0!==e&&t.set(o,e)}}}const n=new Map;{const t=new Map;for(let n=0;n<e.length;++n){const r=e[n];let o=t.get(r.name);void 0===o&&(o=[],t.set(r.name,o)),o.push({index:n,value:r})}for(let e=0;e<u.length;++e){const r=u[e],o=t.get(r.name);if(void 0!==o)if(1===o.length)n.set(r,o[0].value);else{let t;for(let n=0;n<o.length;++n)if(o[n].index===e){t=o[n].value;break}void 0!==t&&n.set(r,t)}}}const r=new Map;for(let t=0;t<e.length;++t){const n=e[t];let o=r.get(e[n.parentBoneIndex]);void 0===o&&0<=n.parentBoneIndex&&n.parentBoneIndex<e.length&&(o=[],r.set(e[n.parentBoneIndex],o)),o?.push(n)}const o=new Map;for(let e=0;e<u.length;++e){if(null!==u[e].getParent())continue;const t=[u[e]];for(o.set(u[e],u[e].getRestMatrix());t.length>0;){const e=t.pop(),n=o.get(e),r=e.children;for(let e=0;e<r.length;++e){const i=r[e];o.set(i,i.getRestMatrix().multiply(n)),t.push(i)}}}const i=new Map;for(let s=0;s<e.length;++s){const a=e[s];let l=t.get(a);const c=[],u=e=>{const t=e.children;for(let r=0;r<t.length;++r){const o=t[r],s=n.get(o);void 0===s?(c.push(e),u(o)):i.has(s)||i.set(s,d.length+c.length)}};if(void 0!==l)u(l);else{const e=r.get(a);if(void 0!==e)for(let t=0;t<e.length;++t){const n=e[t];i.set(n,d.length+c.length)}}const g=e=>{const n=r.get(e);if(void 0!==n)for(let e=0;e<n.length;++e){const r=n[e];let o=t.get(r);if(void 0!==o)return o;if(o=g(r),void 0!==o)return o}};if(void 0===l&&(l=g(a)),void 0===l){let n=e[a.parentBoneIndex];for(;void 0!==n&&(l=t.get(n),void 0===l);)n=e[n.parentBoneIndex]}const f=a.name,m=a.englishName,x=void 0!==l?o.get(l).getTranslation().asArray():[0,0,0],y=-1,A=a.transformOrder,T=a.tailPosition??-2,_=a.appendTransform,b=a.axisLimit,I=a.localVector,w=a.externalParentTransform,v=a.ik;let E=0;E=a.flag?a.flag:M.Bone.Flag.IsRotatable|M.Bone.Flag.IsMovable|M.Bone.Flag.IsVisible|M.Bone.Flag.IsControllable,E&=(Array.isArray(T)?~M.Bone.Flag.UseBoneIndexAsTailPosition:-1)&(_?-1:~M.Bone.Flag.HasAppendRotate|~M.Bone.Flag.HasAppendMove)&(b?-1:~M.Bone.Flag.HasAxisLimit)&(I?-1:~M.Bone.Flag.HasLocalVector)&(w?-1:~M.Bone.Flag.IsExternalParentTransformed)&(v?-1:~M.Bone.Flag.IsIkEnabled),E|=(Array.isArray(T)?0:M.Bone.Flag.UseBoneIndexAsTailPosition)|(_?M.Bone.Flag.HasAppendRotate|M.Bone.Flag.HasAppendMove:0)|(b?M.Bone.Flag.HasAxisLimit:0)|(I?M.Bone.Flag.HasLocalVector:0)|(w?M.Bone.Flag.IsExternalParentTransformed:0)|(v?M.Bone.Flag.IsIkEnabled:0);const S={name:f,englishName:m,position:x,parentBoneIndex:y,transformOrder:A,flag:E,tailPosition:T,appendTransform:_,axisLimit:b,localVector:I,externalParentTransform:w,ik:v},C=h[s]=d.length;void 0!==l&&(p[l.getIndex()]=C),d.push(S);const F=M.Bone.Flag.UseBoneIndexAsTailPosition|M.Bone.Flag.IsRotatable|M.Bone.Flag.IsVisible|M.Bone.Flag.IsControllable;for(let e=0;e<c.length;++e){const t=c[e];p[t.getIndex()]=d.length;let r=-1;const i=t.getParent();null!==i&&(r=n.get(i)===a?C:p[i.getIndex()]),d.push({name:t.name,englishName:"",position:o.get(t).getTranslation().asArray(),parentBoneIndex:r,transformOrder:0,flag:F,tailPosition:r,appendTransform:void 0,axisLimit:void 0,localVector:void 0,externalParentTransform:void 0,ik:void 0})}}for(let t=0;t<e.length;++t){const n=e[t],r=d[h[t]],o=r.parentBoneIndex=i.get(n)??-1;-2===r.tailPosition?r.tailPosition=o:"number"==typeof r.tailPosition&&0<=r.tailPosition&&r.tailPosition<e.length&&(r.tailPosition=h[r.tailPosition]);const s=r.appendTransform;void 0!==s&&(r.appendTransform={parentIndex:h[s.parentIndex]??s.parentIndex,ratio:s.ratio});const a=r.ik;if(void 0!==a){const e=[];r.ik={target:h[a.target]??a.target,iteration:a.iteration,rotationConstraint:a.rotationConstraint,links:e};const t=a.links;for(let n=0;n<t.length;++n){const r=t[n];e.push({target:h[r.target]??r.target,limitation:r.limitation})}}}}const f=[],m=new Map;{const e=a.meshes;for(let t=0;t<e.length;++t){const n=e[t];if(null===n.geometry){this.warn(`mesh ${n.name} has no geometry. skippping`);continue}const o=n.geometry;null!==o.getVerticesData(r.R.PositionKind)?null!==o.getVerticesData(r.R.NormalKind)?null!==o.getVerticesData(r.R.UVKind)?n.isUnIndexed||null!==o.getIndices()?null===a.skeleton||a.skeleton===n.skeleton?(m.set(t,f.length),f.push(n)):this.warn(`mesh ${n.name} has different skeleton. skippping`):this.warn(`mesh ${n.name} has no indices data. skippping`):this.warn(`mesh ${n.name} has no uv data. skippping`):this.warn(`mesh ${n.name} has no normal data. skippping`):this.warn(`mesh ${n.name} has no position data. skippping`)}}const x=[],y=[];{const e=new Set;for(let t=0;t<f.length;++t){const n=f[t].material;if(null===n)continue;const r=n.subMaterials??[n];for(let t=0;t<r.length;++t){const n=r[t];if(null!==n&&(n.diffuseTexture?e.add(n.diffuseTexture):n.albedoTexture&&e.add(n.albedoTexture),n.sphereTexture&&e.add(n.sphereTexture),n.toonTexture)){const t=n.toonTexture.name;t.startsWith("file:shared_toon_texture_")&&t.length<=27&&!isNaN(Number(t.substring(25)))||e.add(n.toonTexture)}}}const t=l?a.textureNameMap:null;null===t&&this.warn("metadata.textureNameMap is not defined. texture names will be fallback to converted string by loader");const n=new Map,r=new Map;for(const o of e){let e=null;const i=o._buffer;i instanceof ArrayBuffer?e=new Uint8Array(i):null==i?this.warn(`texture ${o.name} has no texture buffer. make sure load model with materialBuilder.deleteTextureBufferAfterLoad = false`):i.buffer instanceof ArrayBuffer?e=new Uint8Array(i.buffer,i.byteOffset,i.byteLength):this.warn(`texture ${o.name} has unsupported type of texture buffer. only ArrayBuffer and TypedArray is supported`);const s=(o.noMipmap?_e.Texture.Flag.NoMipmap:0)|(o.invertY?_e.Texture.Flag.InvertY:0);let a;if(null!==e){let i=r.get(e.buffer);void 0===i&&(i=r.size,r.set(e.buffer,i));const s=`${i}_${e.byteOffset}_${e.byteLength}`;if(a=n.get(s),void 0===a){a=x.length,n.set(s,a);let r=t?.get(o);void 0===r&&(this.warn(`texture ${o.name} has no name in textureNameMap. falling back to converted string by loader`),r=o.name),x.push({relativePath:r,mimeType:o.mimeType,buffer:e})}}y.push({flag:s,samplingMode:o.samplingMode,imageIndex:a??-1,texture:o})}}const A=[],T=new Map;{const e=new Map;{const t=a.materials;for(let n=0;n<t.length;++n){const r=t[n];e.set(r,n)}}const t=new Map;{const e=a.materials,n=l?a.materialsMetadata:null;if(null!==n)for(let r=0;r<e.length;++r){const o=e[r],i=n[r];t.has(o)||void 0!==i&&t.set(o,i)}}let n=!1;const r=new Map;for(let o=0;o<f.length;++o){const a=f[o],l=[];{const e=a.material?.subMaterials??[a.material],t=a.subMeshes;for(let n=0;n<t.length;++n){const r=e[t[n].materialIndex];l.push(r)}}for(let o=0;o<l.length;++o){const d=l[o];if(null===d){if(n)this.warn(`mesh ${a.name} has no material. using default material metadata`);else{n=!0,this.warn(`mesh ${a.name} has no material. adding default material metadata`);const e={name:"default",englishName:"default",diffuse:[1,1,1,1],specular:[0,0,0],shininess:0,ambient:[0,0,0],evaluatedTransparency:0,flag:0,edgeColor:[0,0,0,1],edgeSize:0,textureIndex:-1,sphereTextureIndex:-1,sphereTextureMode:M.Material.SphereTextureMode.Off,isSharedToonTexture:!1,toonTextureIndex:-1,comment:"",linkedMaterial:null};A.push(e)}continue}const h=r.get(d),c=e.get(d);if(void 0===c)this.warn(`mesh ${a.name} has material which is not included in model metadata`);else if(void 0!==h)T.set(c,h);else{T.set(c,A.length),r.set(d,A.length);const e=t.get(d);void 0===e&&this.log(`mesh ${a.name} has no additional material metadata`);const n=d.name??"",o=e?.englishName??"",l=d.diffuseColor?.asArray()??[1,1,1,1];l.length=4,l[3]=d.alpha??1;const h=d.specularColor?.asArray()??d.reflectivityColor?.asArray()??[0,0,0];h.length=3;const u=d.specularPower??0,g=d.ambientColor?.asArray()??[0,0,0];g.length=3;const p=(3&+(i[c]??-1))<<4|(15&(s[c]??-1))<<0,f=(!1===d.backFaceCulling?M.Material.Flag.IsDoubleSided:0)|(d.renderOutline?M.Material.Flag.EnabledToonEdge:0),m=d.outlineColor?.asArray()??[0,0,0];m.length=4,m[3]=d.outlineAlpha??0;const x=d.outlineWidth??0,_=d.diffuseTexture??d.albedoTexture,b=_?y.findIndex((e=>e.texture===_)):-1,I=d.sphereTexture,w=I?y.findIndex((e=>e.texture===I)):-1,v=d.sphereTextureBlendMode??M.Material.SphereTextureMode.Off,E=d.toonTexture,S=!!E&&E.name.startsWith("file:shared_toon_texture_")&&E.name.length<=27&&!isNaN(Number(E.name.substring(25)));let C;C=S?Number(E.name.substring(25))-1:E?y.findIndex((e=>e.texture===E)):-1;const F={name:n,englishName:o,diffuse:l,specular:h,shininess:u,ambient:g,evaluatedTransparency:p,flag:f,edgeColor:m,edgeSize:x,textureIndex:b,sphereTextureIndex:w,sphereTextureMode:v,isSharedToonTexture:S,toonTextureIndex:C,comment:e?.comment??"",linkedMaterial:d};A.push(F)}}}}const _=new Array(a.morphs.length).fill(null);for(let e=0;e<_.length;++e)_[e]=[];if(o)if(l){const e=a.morphs;for(let t=0;t<e.length;++t){const n=e[t];switch(n.type){case M.Morph.Type.VertexMorph:case M.Morph.Type.UvMorph:case M.Morph.Type.AdditionalUvMorph1:case M.Morph.Type.AdditionalUvMorph2:case M.Morph.Type.AdditionalUvMorph3:case M.Morph.Type.AdditionalUvMorph4:{const e=[],r=n.elements;for(let t=0;t<r.length;++t){const o=r[t],i=m.get(o.meshIndex);void 0!==i?e.push({meshIndex:i,indices:o.indices,offsets:o.offsets}):this.warn(`morph ${n.name} has invalid mesh. skipping`)}_[t]=e}}}}else{this.warn("metadata.morphsMetadata is not defined. UV morphs will be lossy converted");const e=a.morphs;for(let t=0;t<e.length;++t){const n=e[t];let o=!1;switch(n.type){case M.Morph.Type.VertexMorph:case M.Morph.Type.UvMorph:case M.Morph.Type.AdditionalUvMorph1:case M.Morph.Type.AdditionalUvMorph2:case M.Morph.Type.AdditionalUvMorph3:case M.Morph.Type.AdditionalUvMorph4:o=!0}if(!o)continue;const i=_[t]=[],s=n.morphTargets;for(let e=0;e<s.length;++e){let t=-1;const o=s[e];e:for(let e=0;e<f.length;++e){const n=f[e].morphTargetManager;if(null===n)continue;const r=n.numTargets;for(let i=0;i<r;++i)if(n.getTarget(i)===o){t=e;break e}}if(-1===t){this.warn(`morph ${n.name} has no target mesh. skipping`);continue}let a,l,d=0;if(n.type===M.Morph.Type.VertexMorph){const e=f[t].geometry.getVerticesData(r.R.PositionKind),i=o.getPositions();if(null===i){this.warn(`morph ${n.name} has no positions data. skipping`);continue}if(e.length!==i.length){this.warn(`morph ${n.name} has different number of positions. skipping`);continue}for(let t=0;t<e.length;t+=3)e[t+0]===i[t+0]&&e[t+1]===i[t+1]&&e[t+2]===i[t+2]||(d+=1);a=new Int32Array(d),l=new Float32Array(3*d);const s=e.length/3;for(let t=0,n=0;t<s;++t)e[3*t+0]===i[3*t+0]&&e[3*t+1]===i[3*t+1]&&e[3*t+2]===i[3*t+2]||(a[n]=t,l[3*n+0]=i[3*t+0]-e[3*t+0],l[3*n+1]=i[3*t+1]-e[3*t+1],l[3*n+2]=i[3*t+2]-e[3*t+2],n+=1)}else{const e=f[t].geometry.getVerticesData(r.R.UVKind),i=o.getUVs();if(null===i){this.warn(`morph ${n.name} has no uvs data. skipping`);continue}if(e.length!==i.length){this.warn(`morph ${n.name} has different number of uvs. skipping`);continue}for(let t=0;t<e.length;t+=2)e[t+0]===i[t+0]&&e[t+1]===i[t+1]||(d+=1);a=new Int32Array(d),l=new Float32Array(4*d);const s=e.length/2;for(let t=0,n=0;t<s;++t)e[2*t+0]===i[2*t+0]&&e[2*t+1]===i[2*t+1]||(a[n]=t,l[4*n+0]=i[2*t+0]-e[2*t+0],l[4*n+1]=i[2*t+1]-e[2*t+1],n+=1)}i.push({meshIndex:t,indices:a,offsets:l})}}}const b=new TextEncoder;let I=7;{const e=a.header;I+=4+b.encode(e.modelName).length,I+=4+b.encode(e.englishModelName).length,I+=4+b.encode(e.comment).length,I+=4+b.encode(e.englishComment).length,I+=1,I+=4;for(let e=0;e<f.length;++e){const t=f[e],n=t.geometry;I+=4+b.encode(t.name).length,I+=4;const o=t.material;if(void 0!==o?.subMaterials){const e=o.subMaterials;I+=4;for(let t=0;t<e.length;++t)I+=4,I+=4,I+=4,I+=4,I+=4}I+=4;const i=n.getVerticesData(r.R.PositionKind);I+=4*i.length;const s=i.length/3;if(I+=3*s*4,I+=2*s*4,I+=1,null!==n.getVerticesData(g.V.AdditionalUV1Kind)&&(I+=4*s*4),null!==n.getVerticesData(g.V.AdditionalUV2Kind)&&(I+=4*s*4),null!==n.getVerticesData(g.V.AdditionalUV3Kind)&&(I+=4*s*4),null!==n.getVerticesData(g.V.AdditionalUV4Kind)&&(I+=4*s*4),I+=1,!t.isUnIndexed){I+=1,I+=4;const e=n.getIndices();I+=Array.isArray(e)?4*e.length:e.byteLength}0!==d.length&&(null===n.getVerticesData(r.R.MatricesIndicesKind)&&this.warn(`mesh ${t.name} has no matricesIndices data. falling back to zero matricesIndices`),I+=4*s*4,null===n.getVerticesData(r.R.MatricesWeightsKind)&&this.warn(`mesh ${t.name} has no matricesWeights data. falling back to zero matricesWeights`),I+=4*s*4);const a=n.getVerticesData(g.V.MatricesSdefCKind),l=n.getVerticesData(g.V.MatricesSdefR0Kind),h=n.getVerticesData(g.V.MatricesSdefR1Kind);null!==a&&null!==l&&null!==h?(I+=3*s*4,I+=3*s*4,I+=3*s*4):null!==a&&null!==l&&null!==h||null===a&&null===l&&null===h||this.warn(`mesh ${t.name} has incomplete sdef data. sdefC, sdefR0, sdefR1 must be all defined or all undefined. falling back to linear blend skinning`),null!==n.getVerticesData(g.V.EdgeScaleKind)&&(I+=4*s)}I+=4;for(let e=0;e<x.length;++e){const t=x[e];I+=4+b.encode(t.relativePath).length,I+=1,void 0!==t.mimeType&&(I+=4+b.encode(t.mimeType).length),I+=4,I+=t.buffer.byteLength}I+=4;for(let e=0;e<y.length;++e)I+=6;I+=4;for(let e=0;e<A.length;++e){const t=A[e];I+=4+b.encode(t.name).length,I+=4+b.encode(t.englishName).length,I+=16,I+=12,I+=4,I+=12,I+=1,I+=1,I+=16,I+=4,I+=4,I+=4,I+=1,I+=1,I+=4,I+=4+b.encode(t.comment).length}if(0!==d.length){I+=4,l||this.warn("metadata.bones has following missing properties: tailPosition, axisLimit, localVector, externalParentTransform. lossy conversion will be applied");for(let e=0;e<d.length;++e){const t=d[e];if(I+=4+b.encode(t.name).length,I+=4+b.encode(t.englishName).length,I+=12,I+=4,I+=4,I+=2,l?"number"==typeof t.tailPosition?I+=4:I+=12:I+=4,void 0!==t.appendTransform&&(I+=4,I+=4),void 0!==t.axisLimit&&(I+=12),void 0!==t.localVector&&(I+=12,I+=12),void 0!==t.externalParentTransform&&(I+=4),void 0!==t.ik){I+=4,I+=4,I+=4,I+=4;const e=t.ik.links;for(let t=0;t<e.length;++t)I+=4,I+=1,void 0!==e[t].limitation&&(I+=12,I+=12)}}}I+=4;const t=a.morphs;for(let e=0;e<t.length;++e){const n=t[e];switch(I+=4+b.encode(n.name).length,I+=4+b.encode(n.englishName).length,I+=1,I+=1,n.type){case M.Morph.Type.GroupMorph:I+=4+8*n.indices.length;break;case M.Morph.Type.VertexMorph:{I+=4;const t=_[e];for(let e=0;e<t.length;++e){const n=t[e];I+=8+4*n.indices.length+4*n.offsets.length}}break;case M.Morph.Type.BoneMorph:I+=4+32*n.indices.length;break;case M.Morph.Type.UvMorph:case M.Morph.Type.AdditionalUvMorph1:case M.Morph.Type.AdditionalUvMorph2:case M.Morph.Type.AdditionalUvMorph3:case M.Morph.Type.AdditionalUvMorph4:{I+=4;const t=_[e];for(let e=0;e<t.length;++e){const n=t[e];I+=8+4*n.indices.length+4*n.offsets.length}}break;case M.Morph.Type.MaterialMorph:I+=4+117*n.elements.length}}if(I+=4,l&&null!==a.displayFrames){const e=a.displayFrames;for(let t=0;t<e.length;++t){const n=e[t];I+=4+b.encode(n.name).length,I+=4+b.encode(n.englishName).length,I+=1,I+=4,I+=5*n.frames.length}}I+=4;const n=a.rigidBodies;for(let e=0;e<n.length;++e){const t=n[e];I+=4+b.encode(t.name).length,I+=4+b.encode(t.englishName).length,I+=4,I+=1,I+=2,I+=1,I+=12,I+=12,I+=12,I+=4,I+=4,I+=4,I+=4,I+=4,I+=1}I+=4;const o=a.joints;for(let e=0;e<o.length;++e){const t=o[e];I+=4+b.encode(t.name).length,I+=4+b.encode(t.englishName).length,I+=1,I+=4,I+=4,I+=12,I+=12,I+=12,I+=12,I+=12,I+=12,I+=12,I+=12}}const w=new ArrayBuffer(I),v=new Ce(w);v.setUint8Array(b.encode("BPMX")),v.setInt8Array([2,2,1]);{const e=a.header;v.setString(e.modelName),v.setString(e.englishModelName),v.setString(e.comment),v.setString(e.englishComment)}const E=0!==d.length?_e.Geometry.MeshType.IsSkinnedMesh:0;v.setUint8(E),v.setUint32(f.length);for(let e=0;e<f.length;++e){const t=f[e],n=t.geometry;v.setString(t.name);let o=!1;if(1<t.subMeshes.length||0===t.subMeshes.length)o=!0;else{const e=t.subMeshes[0];0===e.materialIndex&&0===e.verticesStart&&e.verticesCount===n.getTotalVertices()&&0===e.indexStart&&e.indexCount===n.getTotalIndices()||(o=!0)}if(o){v.setInt32(-2);const e=t.subMeshes;v.setUint32(e.length);const n=t.material?.subMaterials??[t.material];for(let t=0;t<e.length;++t){const r=e[t],o=n[r.materialIndex]??null,i=A.findIndex((e=>e.linkedMaterial===o));v.setInt32(i),v.setUint32(r.verticesStart),v.setUint32(r.verticesCount),v.setUint32(r.indexStart),v.setUint32(r.indexCount)}}else{const e=t.material,n=A.findIndex((t=>t.linkedMaterial===e));v.setInt32(n)}const i=n.getVerticesData(r.R.PositionKind),s=i.length/3;v.setUint32(s),v.setFloat32Array(i);let a=n.getVerticesData(r.R.NormalKind);if(a.length!==3*s){this.warn(`mesh ${t.name} normals vertex count is different from positions vertex count`);const e=new Float32Array(3*s);e.set(a),a=e}v.setFloat32Array(a);let l=n.getVerticesData(r.R.UVKind);if(l.length!==2*s){this.warn(`mesh ${t.name} uv vertex count is different from positions vertex count`);const e=new Float32Array(2*s);e.set(l),l=e}v.setFloat32Array(l);const h=[];{const e=n.getVerticesData(g.V.AdditionalUV1Kind);null!==e&&h.push(e);const t=n.getVerticesData(g.V.AdditionalUV2Kind);null!==t&&h.push(t);const r=n.getVerticesData(g.V.AdditionalUV3Kind);null!==r&&h.push(r);const o=n.getVerticesData(g.V.AdditionalUV4Kind);null!==o&&h.push(o)}v.setUint8(h.length);for(let e=0;e<h.length;++e){const n=h[e];if(n.length!==4*s){this.warn(`mesh ${t.name} additional uv vertex count is different from positions vertex count`);const r=new Float32Array(4*s);r.set(n),h[e]=r}v.setFloat32Array(n)}let c=n.getVerticesData(g.V.MatricesSdefCKind),u=n.getVerticesData(g.V.MatricesSdefR0Kind),m=n.getVerticesData(g.V.MatricesSdefR1Kind);const x=null!==c&&null!==u&&null!==m;let y=n.getVerticesData(g.V.EdgeScaleKind);const T=(x?_e.Geometry.GeometryType.HasSdef:0)|(t.isUnIndexed?0:_e.Geometry.GeometryType.IsIndexed)|(null!==y?_e.Geometry.GeometryType.HasEdgeScale:0);if(v.setUint8(T),!t.isUnIndexed){const e=n.getIndices();v.setUint8(e instanceof Uint32Array?_e.Geometry.IndexElementType.Uint32:e instanceof Uint16Array?_e.Geometry.IndexElementType.Uint16:_e.Geometry.IndexElementType.Int32),v.setUint32(e.length),e instanceof Uint16Array?v.setUint16Array(e):e instanceof Uint32Array?v.setUint32Array(e):v.setInt32Array(e)}if(0!==d.length){const e=new Float32Array(4*s);{const o=n.getVerticesData(r.R.MatricesIndicesKind);if(null!==o&&o.length===4*s||this.warn(`mesh ${t.name} bone indices vertex count is different from positions vertex count`),null!==o)for(let t=0;t<e.length;++t)e[t]=p[o[t]]??o[t]}v.setFloat32Array(e);let o=n.getVerticesData(r.R.MatricesWeightsKind);if(null===o&&(o=new Float32Array(4*s)),o.length!==4*s){this.warn(`mesh ${t.name} bone weights vertex count is different from positions vertex count`);const e=new Float32Array(4*s);e.set(o),o=e}if(v.setFloat32Array(o),x){if(c.length!==3*s){this.warn(`mesh ${t.name} sdefC vertex count is different from positions vertex count`);const e=new Float32Array(3*s);e.set(c),c=e}if(u.length!==3*s){this.warn(`mesh ${t.name} sdefR0 vertex count is different from positions vertex count`);const e=new Float32Array(3*s);e.set(u),u=e}if(m.length!==3*s){this.warn(`mesh ${t.name} sdefR1 vertex count is different from positions vertex count`);const e=new Float32Array(3*s);e.set(m),m=e}v.setFloat32Array(c),v.setFloat32Array(u),v.setFloat32Array(m)}}if(null!==y){if(y.length!==s){this.warn(`mesh ${t.name} edgeScale vertex count is different from positions vertex count`);const e=new Float32Array(s);e.set(y),y=e}v.setFloat32Array(y)}}v.setUint32(x.length);for(let e=0;e<x.length;++e){const t=x[e];v.setString(t.relativePath);const n=void 0!==t.mimeType?_e.Image.Flag.HasMimeType:0;v.setUint8(n),void 0!==t.mimeType&&v.setString(t.mimeType),v.setUint32(t.buffer.byteLength),v.setUint8Array(t.buffer)}v.setUint32(y.length);for(let e=0;e<y.length;++e){const t=y[e];v.setUint8(t.flag),v.setUint8(t.samplingMode),v.setInt32(t.imageIndex)}v.setUint32(A.length);for(let e=0;e<A.length;++e){const t=A[e];v.setString(t.name),v.setString(t.englishName),v.setFloat32Array(t.diffuse),v.setFloat32Array(t.specular),v.setFloat32(t.shininess),v.setFloat32Array(t.ambient),v.setUint8(t.evaluatedTransparency),v.setUint8(t.flag),v.setFloat32Array(t.edgeColor),v.setFloat32(t.edgeSize),v.setInt32(t.textureIndex),v.setInt32(t.sphereTextureIndex),v.setUint8(t.sphereTextureMode),v.setUint8(t.isSharedToonTexture?1:0),v.setInt32(t.toonTextureIndex),v.setString(t.comment)}if(0!==d.length){v.setUint32(d.length);for(let e=0;e<d.length;++e){const t=d[e];if(v.setString(t.name),v.setString(t.englishName),v.setFloat32Array(t.position),v.setInt32(t.parentBoneIndex),v.setInt32(t.transformOrder),v.setUint16(t.flag),"number"==typeof t.tailPosition?v.setInt32(t.tailPosition):v.setFloat32Array(t.tailPosition),void 0!==t.appendTransform&&(v.setInt32(t.appendTransform.parentIndex),v.setFloat32(t.appendTransform.ratio)),void 0!==t.axisLimit&&v.setFloat32Array(t.axisLimit),void 0!==t.localVector&&(v.setFloat32Array(t.localVector.x),v.setFloat32Array(t.localVector.z)),void 0!==t.externalParentTransform&&v.setInt32(t.externalParentTransform),void 0!==t.ik){const e=t.ik;v.setInt32(e.target),v.setInt32(e.iteration),v.setFloat32(e.rotationConstraint);const n=e.links;v.setInt32(n.length);for(let e=0;e<n.length;++e){const t=n[e];v.setInt32(t.target),v.setUint8(void 0!==t.limitation?1:0),void 0!==t.limitation&&(v.setFloat32Array(t.limitation.minimumAngle),v.setFloat32Array(t.limitation.maximumAngle))}}}}v.setUint32(a.morphs.length);const S=a.morphs;for(let e=0;e<S.length;++e){const t=S[e];switch(v.setString(t.name),v.setString(t.englishName),v.setUint8(t.category),v.setUint8(t.type),t.type){case M.Morph.Type.GroupMorph:{v.setUint32(t.indices.length),v.setInt32Array(t.indices);let e=t.ratios;if(e.length!==t.indices.length){this.warn(`morph ${t.name} group morph ratio count is different from indices count`);const n=new Float32Array(t.indices.length);n.set(e),e=n}v.setFloat32Array(e)}break;case M.Morph.Type.VertexMorph:case M.Morph.Type.UvMorph:case M.Morph.Type.AdditionalUvMorph1:case M.Morph.Type.AdditionalUvMorph2:case M.Morph.Type.AdditionalUvMorph3:case M.Morph.Type.AdditionalUvMorph4:{const n=_[e];v.setUint32(n.length);for(let e=0;e<n.length;++e){const r=n[e];v.setUint32(r.meshIndex),v.setUint32(r.indices.length),v.setInt32Array(r.indices);let o=r.offsets;const i=t.type===M.Morph.Type.VertexMorph?3:4;if(o.length!==r.indices.length*i){this.warn(`morph ${t.name} vertex/uv morph offset count is different from indices count`);const e=new Float32Array(r.indices.length*i);e.set(o),o=e}v.setFloat32Array(o)}}break;case M.Morph.Type.BoneMorph:{const e=new Int32Array(t.indices.length);{const n=t.indices;for(let t=0;t<n.length;++t)e[t]=h[n[t]]??n[t]}v.setUint32(e.length),v.setInt32Array(e);let n=t.positions;if(n.length!==3*e.length){this.warn(`morph ${t.name} bone morph position count is different from indices count`);const r=new Float32Array(3*e.length);r.set(n),n=r}v.setFloat32Array(n);let r=t.rotations;if(r.length!==4*e.length){this.warn(`morph ${t.name} bone morph rotation count is different from indices count`);const n=new Float32Array(4*e.length);n.set(r),r=n}v.setFloat32Array(r)}break;case M.Morph.Type.MaterialMorph:{v.setUint32(t.elements.length);const e=t.elements;for(let t=0;t<e.length;++t){const n=e[t],r=T.get(n.index)??n.index;v.setInt32(r),v.setUint8(n.type),v.setFloat32Array(n.diffuse),v.setFloat32Array(n.specular),v.setFloat32(n.shininess),v.setFloat32Array(n.ambient),v.setFloat32Array(n.edgeColor),v.setFloat32(n.edgeSize),v.setFloat32Array(n.textureColor),v.setFloat32Array(n.sphereTextureColor),v.setFloat32Array(n.toonTextureColor)}}break;default:v.setUint32(0)}}if(l&&null!==a.displayFrames){v.setUint32(a.displayFrames.length);const e=a.displayFrames;for(let t=0;t<e.length;++t){const n=e[t];v.setString(n.name),v.setString(n.englishName),v.setUint8(n.isSpecialFrame?1:0),v.setUint32(n.frames.length);const r=n.frames;for(let e=0;e<r.length;++e){const t=r[e];v.setUint8(t.type);const n=t.type===M.DisplayFrame.FrameData.FrameType.Bone?h[t.index]??t.index:t.index;v.setInt32(n)}}}else v.setUint32(0);v.setUint32(a.rigidBodies.length);const C=a.rigidBodies;for(let e=0;e<C.length;++e){const t=C[e];v.setString(t.name),v.setString(t.englishName),v.setInt32(h[t.boneIndex]??t.boneIndex),v.setUint8(t.collisionGroup),v.setUint16(t.collisionMask),v.setUint8(t.shapeType),v.setFloat32Array(t.shapeSize),v.setFloat32Array(t.shapePosition),v.setFloat32Array(t.shapeRotation),v.setFloat32(t.mass),v.setFloat32(t.linearDamping),v.setFloat32(t.angularDamping),v.setFloat32(t.repulsion),v.setFloat32(t.friction),v.setUint8(t.physicsMode)}v.setUint32(a.joints.length);const F=a.joints;for(let e=0;e<F.length;++e){const t=F[e];v.setString(t.name),v.setString(t.englishName),v.setUint8(t.type),v.setInt32(t.rigidbodyIndexA),v.setInt32(t.rigidbodyIndexB),v.setFloat32Array(t.position),v.setFloat32Array(t.rotation),v.setFloat32Array(t.positionMin),v.setFloat32Array(t.positionMax),v.setFloat32Array(t.rotationMin),v.setFloat32Array(t.rotationMax),v.setFloat32Array(t.springPosition),v.setFloat32Array(t.springRotation)}return 0!==v.bytesAvailable&&this.error(`unexpected bytes available: ${v.bytesAvailable}`),w}get loggingEnabled(){return this._loggingEnabled}set loggingEnabled(e){this._loggingEnabled=e,e?(this.log=this._logEnabled,this.warn=this._warnEnabled,this.error=this._errorEnabled):(this.log=this._logDisabled,this.warn=this._warnDisabled,this.error=this._errorDisabled)}_logEnabled(e){V.V.Log(e)}_logDisabled(){}_warnEnabled(e){V.V.Warn(e)}_warnDisabled(){}_errorEnabled(e){V.V.Error(e)}_errorDisabled(){}}class Be{static OverrideComputeTransformMatrices(e){e._computeTransformMatrices=function(e,t){this.onBeforeComputeObservable.notifyObservers(this);for(let n=0;n<this.bones.length;n++){const r=this.bones[n];if(r._childUpdateId+=1,!r.getParent()){const o=[r];for(;o.length>0;){const r=o.pop(),i=r.getParent();if(i?r.getLocalMatrix().multiplyToRef(i.getFinalMatrix(),r.getFinalMatrix()):t?r.getLocalMatrix().multiplyToRef(t,r.getFinalMatrix()):r.getFinalMatrix().copyFrom(r.getLocalMatrix()),-1!==r._index){const t=null===r._index?n:r._index;r.getAbsoluteInverseBindMatrix().multiplyToArray(r.getFinalMatrix(),e,16*t)}const s=r.getChildren();for(const e of s)o.push(e)}}}this._identity.copyToArray(e,16*this.bones.length)}}}async function Ue(e,t=""){const n=[];for(let r=0;r<e.length;++r){const o=e[r];if(o.isDirectory){const e=o.createReader(),r=await new Promise(((t,n)=>{e.readEntries(t,n)}));n.push(...await Ue(r,t+o.name+"/"))}else n.push(o)}return n}class Re{async build(e,t){y.OverrideEngineCreateEffect(t);const n=new de;n.deleteTextureBufferAfterLoad=!1,n.renderMethod=ie.AlphaEvaluation;const r=new c.Z(t);r.ambientColor=new O.v9(.5,.5,.5);const o=new be.L("camera",0,0,45,new h.Pq(0,10,0),r);o.maxZ=5e3,o.fov=Math.PI/180*30,o.speed=.5,o.setPosition(new h.Pq(0,10,-45)),o.attachControl(e,!0);const i=new we.g("hemisphericLight",new h.Pq(0,1,0),r);i.intensity=.5,i.specular=new O.v9(0,0,0),i.groundColor=new O.v9(1,1,1);const s=new Ie.Z("directionalLight",new h.Pq(.5,-1,1),r);s.intensity=.5,s.autoCalcShadowZBounds=!1,s.autoUpdateExtends=!1,s.shadowMaxZ=60,s.shadowMinZ=-30,s.orthoTop=54,s.orthoBottom=-3,s.orthoLeft=-30,s.orthoRight=30,s.shadowOrthoScale=0;const a=new ve.o(1024,s,!0,o);a.transparencyShadow=!0,a.usePercentageCloserFiltering=!0,a.forceBackFacesOnly=!1,a.bias=.01,a.filteringQuality=ve.o.QUALITY_MEDIUM,a.frustumEdgeFalloff=.1,(0,Ee.km)("ground1",{width:100,height:100,subdivisions:2,updatable:!1},r).receiveShadows=!0;const l=new Se.e("default",!0,r);l.samples=4,l.fxaaEnabled=!0,l.imageProcessingEnabled=!1;const d=new le(r),u=async e=>{if(A)return;if(null!==p){for(const e of p.metadata.meshes)a.removeShadowCaster(e);p.dispose(!1,!0),p=null}A=!0,t.displayLoadingUI();const o=e.webkitRelativePath;U.textContent=e.name,p=await(0,_.kS)(e,r,{onProgress:n=>t.loadingUIText=`<br/><br/><br/>Loading (${e.name})... ${n.loaded}/${n.total} (${Math.floor(100*n.loaded/n.total)}%)`,rootUrl:o.substring(0,o.lastIndexOf("/")+1),pluginOptions:{mmdmodel:{materialBuilder:n,buildSkeleton:!0,buildMorph:!0,boundingBoxMargin:0,preserveSerializationData:q.checked,loggingEnabled:!0,referenceFiles:E}}}).then((e=>{e.addAllToScene();const t=e.meshes[0];return Be.OverrideComputeTransformMatrices(t.metadata.skeleton),t.metadata.skeleton?._markAsDirty(),t}));{const e=p.metadata.meshes;for(let t=0;t<e.length;++t){const n=e[t];n.receiveShadows=!0,a.addShadowCaster(n,!1),n.alphaIndex=t}const t=p.metadata.materials;f.length=t.length,m.length=t.length;for(let n=0;n<t.length;++n){const r=t[n],o=r.diffuseTexture;if(o&&(o.hasAlpha=!0,r.useAlphaFromDiffuseTexture=!0),r.alpha<1)f[n]=!0;else if(o){f[n]=!0;const t=e.filter((e=>e.material===r));for(const e of t)if(await d.hasFragmentsOnlyOpaqueOnGeometry(o,e,null)){f[n]=!1;break}}else f[n]=!1;m[n]=r.transparencyMode??-1}}Q(),t.hideLoadingUI(),setTimeout((()=>A=!1),1500)};let g=null,p=null;const f=[],m=[];let x="Alpha Mode",A=!1;const T=e=>{if(null===p)return;const t=p.metadata.materials;if("Alpha Mode"===e)for(let e=0;e<t.length;++e){const n=t[e];n.transparencyMode=m[e]??L.i.MATERIAL_OPAQUE,n.forceDepthWrite=!1}else for(let e=0;e<t.length;++e){const n=t[e];n.transparencyMode=f[e]?L.i.MATERIAL_ALPHABLEND:L.i.MATERIAL_OPAQUE,n.forceDepthWrite=!0}},M=e.parentElement;M.style.display="flex",M.style.flexDirection="row-reverse";const b=document.createElement("div");b.style.width="100%",b.style.height="100%",b.style.display="flex",b.appendChild(e),M.appendChild(b);const I=document.createElement("div");I.style.position="relative",I.style.backgroundColor="white",I.style.width="auto",I.style.height="100%",I.style.display="flex",I.style.flexDirection="column",I.style.justifyContent="center",I.style.alignItems="center",I.style.fontFamily="sans-serif",M.appendChild(I);const w=document.createElement("div");w.style.width="auto",w.style.height="100%",w.style.display="flex",w.style.flexDirection="column",w.style.justifyContent="center",w.style.alignItems="start",w.style.padding="20px",w.style.boxSizing="border-box",I.appendChild(w);const v=new Fe;v.loggingEnabled=!0;let E=[];const S=document.createElement("h1");S.textContent="PMX to BPMX Converter",S.style.width="350px",S.style.textAlign="center",S.style.fontSize="24px",S.style.marginTop="0",w.appendChild(S);const C=document.createElement("div");C.style.width="350px",C.style.height="auto",C.style.display="flex",C.style.flexDirection="row",C.style.justifyContent="space-between",C.style.alignItems="center",w.appendChild(C);const F=document.createElement("div");F.textContent="Load Model",F.style.width="100%",F.style.height="auto",F.style.border="none",F.style.backgroundColor="#111111",F.style.fontSize="20px",F.style.textAlign="center",F.style.color="white",F.style.cursor="pointer",F.onclick=()=>{F.style.backgroundColor="#444444",B.style.backgroundColor="#111111",V.style.display="block",R.style.display="block",D.style.display="block",N.style.display="none",K.style.display="none",H.style.display="none"},C.appendChild(F);const B=document.createElement("div");B.textContent="Fix Material",B.style.width="100%",B.style.height="auto",B.style.border="none",B.style.backgroundColor="#111111",B.style.fontSize="20px",B.style.textAlign="center",B.style.color="white",B.style.cursor="pointer",B.onclick=()=>{F.style.backgroundColor="#111111",B.style.backgroundColor="#444444",V.style.display="none",R.style.display="none",D.style.display="none",N.style.display="flex",K.style.display="block",H.style.display="block"},C.appendChild(B);const U=document.createElement("div");U.textContent="No PMX file selected",U.style.width="350px",U.style.height="auto",U.style.fontSize="18px",U.style.marginBottom="10px",U.style.border="1px solid black",U.style.boxSizing="border-box",U.style.padding="10px",U.style.overflow="scroll",w.appendChild(U);const R=document.createElement("div");R.textContent="Files",R.style.width="100%",R.style.height="auto",R.style.fontSize="18px",R.style.backgroundColor="#444444",R.style.color="white",R.style.padding="2px 5px",R.style.boxSizing="border-box",w.appendChild(R);const D=document.createElement("div");D.style.width="350px",D.style.flexGrow="1",D.style.overflow="auto",D.style.marginBottom="10px",D.style.border="1px solid black",D.style.boxSizing="border-box",w.appendChild(D);const P=document.createElement("ul");P.style.height="auto",P.style.fontSize="16px",D.appendChild(P);const k=()=>{P.innerHTML="";for(const e of E){const t=document.createElement("li");t.style.whiteSpace="nowrap";const n=e.webkitRelativePath;t.textContent=n.substring(n.indexOf("/")+1),(e.name.endsWith(".pmx")||e.name.endsWith(".pmd"))&&(t.style.color="blue",t.style.cursor="pointer",t.style.textDecoration="underline",t.onclick=()=>{g=e,u(e)}),P.appendChild(t)}},V=document.createElement("input");V.style.width="100%",V.style.minHeight="80px",V.style.display="block",V.style.backgroundColor="black",V.style.color="white",V.style.marginBottom="10px",V.style.fontSize="20px",V.type="file",V.setAttribute("directory",""),V.setAttribute("webkitdirectory",""),V.setAttribute("allowdirs",""),V.ondragover=e=>{e.preventDefault()},V.ondrop=async e=>{e.preventDefault();const t=e.dataTransfer.items;if(!t)return;const n=[];for(let e=0;e<t.length;++e){const r=t[e].webkitGetAsEntry();r&&n.push(r)}const r=await Ue(n);E=await async function(e){const t=[],n=await Ue(e);for(let e=0;e<n.length;++e){const r=n[e],o=await new Promise(((e,t)=>{r.file(e,t)}));""===o.webkitRelativePath&&(Object.defineProperty(o,"webkitRelativePath",{writable:!0}),o.webkitRelativePath=r.fullPath),t.push(o)}return t}(r),k()},V.onchange=()=>{null!==V.files&&(E=Array.from(V.files),k())},w.appendChild(V);const N=document.createElement("div");N.style.width="100%",N.style.height="auto",N.style.display="flex",N.style.flexDirection="row",N.style.justifyContent="space-between",w.appendChild(N);const z=document.createElement("button");z.textContent="Alpha Mode",z.style.flexGrow="1",z.style.height="auto",z.style.border="none",z.style.fontSize="16px",z.style.backgroundColor="#444444",z.style.color="white",z.style.cursor="pointer",z.onclick=()=>{"Alpha Mode"!==x&&(z.style.backgroundColor="#444444",W.style.backgroundColor="#111111",x="Alpha Mode",T(x),Q())},N.appendChild(z);const W=document.createElement("button");W.textContent="Force Depth Write Mode",W.style.flexGrow="1",W.style.height="auto",W.style.border="none",W.style.fontSize="16px",W.style.backgroundColor="#111111",W.style.color="white",W.style.cursor="pointer",W.onclick=()=>{"Force Depth Write Mode"!==x&&(z.style.backgroundColor="#111111",W.style.backgroundColor="#444444",x="Force Depth Write Mode",T(x),Q())},N.appendChild(W);const K=document.createElement("div");K.textContent="Materials",K.style.width="100%",K.style.height="auto",K.style.fontSize="18px",K.style.backgroundColor="#444444",K.style.color="white",K.style.padding="2px 5px",K.style.boxSizing="border-box",w.appendChild(K);const H=document.createElement("div");H.style.width="350px",H.style.flexGrow="1",H.style.overflow="auto",H.style.marginBottom="10px",H.style.border="1px solid black",H.style.boxSizing="border-box",w.appendChild(H);const G=document.createElement("ol");G.start=0,G.style.height="auto",G.style.fontSize="16px",H.appendChild(G);const Q=()=>{if(G.innerHTML="",null===p)return;const e=p.metadata.meshes;for(let n=0;n<e.length;++n){const r=e[n].material,o=document.createElement("li");if(o.style.padding="5px 0px",o.style.boxSizing="border-box",o.style.whiteSpace="nowrap",o.textContent=r.name,"Alpha Mode"===x){const e=document.createElement("button");e.style.float="right",e.style.width="100px",e.style.height="auto",e.style.fontSize="14px",e.style.marginRight="10px",e.style.border="none",e.textContent=t(r.transparencyMode??0);const i=n;e.onclick=()=>{null===r.transparencyMode&&(r.transparencyMode=0),r.transparencyMode=(r.transparencyMode+1)%3,m[i]=r.transparencyMode,e.textContent=t(r.transparencyMode??0)},o.appendChild(e)}else{const e=document.createElement("button");e.style.float="right",e.style.width="100px",e.style.height="auto",e.style.fontSize="14px",e.style.marginRight="10px",e.style.border="none",e.textContent=r.transparencyMode===L.i.MATERIAL_OPAQUE?"Opaque":"Alpha Blend";const t=n;e.onclick=()=>{r.transparencyMode=r.transparencyMode===L.i.MATERIAL_OPAQUE?L.i.MATERIAL_ALPHABLEND:L.i.MATERIAL_OPAQUE,f[t]=r.transparencyMode===L.i.MATERIAL_ALPHABLEND,e.textContent=r.transparencyMode===L.i.MATERIAL_OPAQUE?"Opaque":"Alpha Blend"},o.appendChild(e)}G.appendChild(o)}function t(e){switch(e){case L.i.MATERIAL_OPAQUE:return"Opaque";case L.i.MATERIAL_ALPHATEST:return"Alpha Test";case L.i.MATERIAL_ALPHABLEND:return"Alpha Blend";default:return"Unknown"}}},j=document.createElement("div");j.style.width="100%",j.style.height="auto",j.style.display="flex",j.style.flexDirection="column",j.style.justifyContent="center",j.style.alignItems="center",j.style.marginBottom="10px",j.style.border="1px solid black",j.style.padding="20px",j.style.boxSizing="border-box",w.appendChild(j);const Y=document.createElement("div");Y.style.width="100%",Y.style.height="30px",Y.style.display="flex",Y.style.flexDirection="row",Y.style.justifyContent="space-between",Y.style.alignItems="center",Y.style.marginBottom="10px",j.appendChild(Y);const X=document.createElement("label");X.textContent="Preserve Serialization Data",X.title="If enabled, the converted file will be larger, but the converted file will be able to be converted back to PMX without any loss of data in technically(currently BPMX to PMX conversion is not supported).",X.style.textAlign="left",X.style.marginRight="10px",X.style.fontSize="16px",Y.appendChild(X);const $=document.createElement("label");$.textContent="(reload required)",$.style.fontSize="11px",$.style.color="gray",$.style.flexGrow="1",Y.appendChild($);const q=document.createElement("input");q.style.width="16px",q.style.height="16px",q.type="checkbox",q.checked=!0,Y.appendChild(q),q.onclick=e=>{A?e.preventDefault():null!==g&&u(g)};const J=document.createElement("div");J.style.width="100%",J.style.height="30px",J.style.display="flex",J.style.flexDirection="row",J.style.justifyContent="space-between",J.style.alignItems="center",J.style.marginBottom="10px",j.appendChild(J);const Z=document.createElement("label");Z.textContent="Build Skeleton",Z.title="If your model don't need to be animated by skeleton(e.g. stage model), you can disable this option to reduce the size of the converted file. also, it can improve the performance of the converted model.",Z.style.textAlign="left",Z.style.marginRight="10px",Z.style.fontSize="16px",Z.style.flexGrow="1",J.appendChild(Z);const ee=document.createElement("input");ee.style.width="16px",ee.style.height="16px",ee.type="checkbox",ee.checked=!0,J.appendChild(ee);const te=document.createElement("div");te.style.width="100%",te.style.height="30px",te.style.display="flex",te.style.flexDirection="row",te.style.justifyContent="space-between",te.style.alignItems="center",te.style.marginBottom="10px",j.appendChild(te);const ne=document.createElement("label");ne.textContent="Build Morph",ne.title="If your model don't need to be animated by morph targets(e.g. stage model), you can disable this option to reduce the size of the converted file. also, it can improve the performance of the converted model.",ne.style.textAlign="left",ne.style.marginRight="10px",ne.style.fontSize="16px",ne.style.flexGrow="1",te.appendChild(ne);const re=document.createElement("input");re.style.width="16px",re.style.height="16px",re.type="checkbox",re.checked=!0,te.appendChild(re);const oe=document.createElement("div");oe.style.width="100%",oe.style.height="auto",oe.style.display="flex",oe.style.flexDirection="row",oe.style.justifyContent="space-between",oe.style.alignItems="center",w.appendChild(oe);const se=document.createElement("button");return se.textContent="Convert",se.style.width="100%",se.style.height="60px",se.style.border="none",se.style.fontSize="20px",oe.appendChild(se),se.onclick=async()=>{if(A)return;if(null===g)return;if(null===p)return;A=!0,t.displayLoadingUI(),t.loadingUIText=`<br/><br/><br/>Converting (${g.name})...`;const e=v.convert(p,{includeSkinningData:ee.checked,includeMorphData:re.checked,translucentMaterials:f,alphaEvaluateResults:m}),n=new Blob([e],{type:"application/octet-stream"}),r=URL.createObjectURL(n),o=document.createElement("a");o.href=r,o.download=`${g.name.substring(0,g.name.lastIndexOf("."))}.bpmx`,o.click(),URL.revokeObjectURL(r),o.remove(),await new Promise((e=>{setTimeout((()=>{t.hideLoadingUI(),e()}),1500)})),A=!1},F.click(),t.resize(!0),r}}},8858:(e,t,n)=>{n.d(t,{y:()=>r});class r{_canvas;_engine;_scene;_onTick;constructor(e){this._canvas=e.canvas,this._engine=e.engine,this._scene=null,this._onTick=null}static async Create(e){const t=new r(e);return t._scene=await t._initialize(e.sceneBuilder),t._onTick=t._makeOnTick(),t}run(){const e=this._engine;window.addEventListener("resize",this._onResize),e.runRenderLoop(this._onTick)}dispose(){window.removeEventListener("resize",this._onResize),this._engine.dispose()}_onResize=()=>{this._engine.resize()};async _initialize(e){return await e.build(this._canvas,this._engine)}_makeOnTick(){const e=this._scene;return()=>e.render()}}},6485:(e,t,n)=>{n.a(e,(async(e,t)=>{try{n(3858),n(615),n(9457),n(7085),n(6845),n(6938);var r=n(8858),o=n(3247);await new Promise((e=>window.onload=e));const e=document.createElement("canvas");let i;e.style.width="100%",e.style.height="100%",e.style.display="block",document.body.appendChild(e),i=new((await n.e(495).then(n.bind(n,7495))).Engine)(e,!1,{preserveDrawingBuffer:!1,stencil:!1,antialias:!0,alpha:!0,premultipliedAlpha:!1,powerPreference:"high-performance",doNotHandleTouchAction:!0,doNotHandleContextLost:!0,audioEngine:!1,disableWebGL2Support:!1},!0),r.y.Create({canvas:e,engine:i,sceneBuilder:new o.u}).then((e=>e.run())),t()}catch(e){t(e)}}),1)}},l={};function d(e){var t=l[e];if(void 0!==t)return t.exports;var n=l[e]={exports:{}};return a[e](n,n.exports,d),n.exports}d.m=a,e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",t="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",n="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",r=e=>{e&&e.d<1&&(e.d=1,e.forEach((e=>e.r--)),e.forEach((e=>e.r--?e.r++:e())))},d.a=(o,i,s)=>{var a;s&&((a=[]).d=-1);var l,d,h,c=new Set,u=o.exports,g=new Promise(((e,t)=>{h=t,d=e}));g[t]=u,g[e]=e=>(a&&e(a),c.forEach(e),g.catch((e=>{}))),o.exports=g,i((o=>{var i;l=(o=>o.map((o=>{if(null!==o&&"object"==typeof o){if(o[e])return o;if(o.then){var i=[];i.d=0,o.then((e=>{s[t]=e,r(i)}),(e=>{s[n]=e,r(i)}));var s={};return s[e]=e=>e(i),s}}var a={};return a[e]=e=>{},a[t]=o,a})))(o);var s=()=>l.map((e=>{if(e[n])throw e[n];return e[t]})),d=new Promise((t=>{(i=()=>t(s)).r=0;var n=e=>e!==a&&!c.has(e)&&(c.add(e),e&&!e.d&&(i.r++,e.push(i)));l.map((t=>t[e](n)))}));return i.r?d:s()}),(e=>(e?h(g[n]=e):d(u),r(a)))),a&&a.d<0&&(a.d=0)},o=[],d.O=(e,t,n,r)=>{if(!t){var i=1/0;for(h=0;h<o.length;h++){for(var[t,n,r]=o[h],s=!0,a=0;a<t.length;a++)(!1&r||i>=r)&&Object.keys(d.O).every((e=>d.O[e](t[a])))?t.splice(a--,1):(s=!1,r<i&&(i=r));if(s){o.splice(h--,1);var l=n();void 0!==l&&(e=l)}}return e}r=r||0;for(var h=o.length;h>0&&o[h-1][2]>r;h--)o[h]=o[h-1];o[h]=[t,n,r]},d.d=(e,t)=>{for(var n in t)d.o(t,n)&&!d.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},d.f={},d.e=e=>Promise.all(Object.keys(d.f).reduce(((t,n)=>(d.f[n](e,t),t)),[])),d.u=e=>e+".bundle.js",d.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),d.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i={},s="babylon-mmd:",d.l=(e,t,n,r)=>{if(i[e])i[e].push(t);else{var o,a;if(void 0!==n)for(var l=document.getElementsByTagName("script"),h=0;h<l.length;h++){var c=l[h];if(c.getAttribute("src")==e||c.getAttribute("data-webpack")==s+n){o=c;break}}o||(a=!0,(o=document.createElement("script")).charset="utf-8",o.timeout=120,d.nc&&o.setAttribute("nonce",d.nc),o.setAttribute("data-webpack",s+n),o.src=e),i[e]=[t];var u=(t,n)=>{o.onerror=o.onload=null,clearTimeout(g);var r=i[e];if(delete i[e],o.parentNode&&o.parentNode.removeChild(o),r&&r.forEach((e=>e(n))),t)return t(n)},g=setTimeout(u.bind(null,void 0,{type:"timeout",target:o}),12e4);o.onerror=u.bind(null,o.onerror),o.onload=u.bind(null,o.onload),a&&document.head.appendChild(o)}},d.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e;d.g.importScripts&&(e=d.g.location+"");var t=d.g.document;if(!e&&t&&(t.currentScript&&"SCRIPT"===t.currentScript.tagName.toUpperCase()&&(e=t.currentScript.src),!e)){var n=t.getElementsByTagName("script");if(n.length)for(var r=n.length-1;r>-1&&(!e||!/^http(s?):/.test(e));)e=n[r--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),d.p=e})(),(()=>{d.b=document.baseURI||self.location.href;var e={792:0};d.f.j=(t,n)=>{var r=d.o(e,t)?e[t]:void 0;if(0!==r)if(r)n.push(r[2]);else{var o=new Promise(((n,o)=>r=e[t]=[n,o]));n.push(r[2]=o);var i=d.p+d.u(t),s=new Error;d.l(i,(n=>{if(d.o(e,t)&&(0!==(r=e[t])&&(e[t]=void 0),r)){var o=n&&("load"===n.type?"missing":n.type),i=n&&n.target&&n.target.src;s.message="Loading chunk "+t+" failed.\n("+o+": "+i+")",s.name="ChunkLoadError",s.type=o,s.request=i,r[1](s)}}),"chunk-"+t,t)}},d.O.j=t=>0===e[t];var t=(t,n)=>{var r,o,[i,s,a]=n,l=0;if(i.some((t=>0!==e[t]))){for(r in s)d.o(s,r)&&(d.m[r]=s[r]);if(a)var h=a(d)}for(t&&t(n);l<i.length;l++)o=i[l],d.o(e,o)&&e[o]&&e[o][0](),e[o]=0;return d.O(h)},n=self.webpackChunkbabylon_mmd=self.webpackChunkbabylon_mmd||[];n.forEach(t.bind(null,0)),n.push=t.bind(null,n.push.bind(n))})();var h=d.O(void 0,[126,71,32],(()=>d(6485)));h=d.O(h)})();