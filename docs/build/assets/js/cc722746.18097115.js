"use strict";(self.webpackChunkbabylon_mmd_docs=self.webpackChunkbabylon_mmd_docs||[]).push([[277],{3588:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>c});var a=t(7462),o=(t(7294),t(3905)),r=t(2004);const i=t.p+"assets/medias/2023-07-29 20-13-24-0ff2c66a869431c63b855234f47a11e1.mp4",s={},l="Multiple Cameras",d={unversionedId:"deep-usage/multiple-cameras/index",id:"deep-usage/multiple-cameras/index",title:"Multiple Cameras",description:"Add one or more cameras to your scene.",source:"@site/docs/1-deep-usage/9-multiple-cameras/index.md",sourceDirName:"1-deep-usage/9-multiple-cameras",slug:"/deep-usage/multiple-cameras/",permalink:"/babylon-mmd/docs/deep-usage/multiple-cameras/",draft:!1,editUrl:"https://github.com/noname0310/babylon-mmd/tree/main/docs/babylon-mmd-docs/docs/1-deep-usage/9-multiple-cameras/index.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Post Processes",permalink:"/babylon-mmd/docs/deep-usage/postprocesses/"}},m={},c=[{value:"Create ArcRotateCamera",id:"create-arcrotatecamera",level:2},{value:"Make ArcRotateCamera Follow Model",id:"make-arcrotatecamera-follow-model",level:2},{value:"Add Camera to PostProcess Render Pipeline",id:"add-camera-to-postprocess-render-pipeline",level:2},{value:"Camera Switching",id:"camera-switching",level:2},{value:"Full Code at this Point",id:"full-code-at-this-point",level:2}],p={toc:c},u="wrapper";function h(e){let{components:n,...t}=e;return(0,o.kt)(u,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"multiple-cameras"},"Multiple Cameras"),(0,o.kt)("p",null,"Add one or more cameras to your scene."),(0,o.kt)("p",null,"Let's put in a user-manipulated camera, one of the simple forms of user-interactive content."),(0,o.kt)("h2",{id:"create-arcrotatecamera"},"Create ArcRotateCamera"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/sceneBuilder.ts"',title:'"src/sceneBuilder.ts"'},'const arcRotateCamera = new ArcRotateCamera("arcRotateCamera", 0, 0, 45, new Vector3(0, 10, 0), scene);\narcRotateCamera.maxZ = 5000;\narcRotateCamera.setPosition(new Vector3(0, 10, -45));\narcRotateCamera.attachControl(canvas, false);\narcRotateCamera.inertia = 0.8;\narcRotateCamera.speed = 10;\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#arc-rotate-camera"},"Camera Introduction | Babylon.js Documentation"))),(0,o.kt)("h2",{id:"make-arcrotatecamera-follow-model"},"Make ArcRotateCamera Follow Model"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/sceneBuilder.ts"',title:'"src/sceneBuilder.ts"'},'const bodyBone = modelMesh.skeleton!.bones.find((bone) => bone.name === "\u30bb\u30f3\u30bf\u30fc");\nconst meshWorldMatrix = modelMesh.getWorldMatrix();\nconst boneWorldMatrix = new Matrix();\nscene.onBeforeRenderObservable.add(() => {\n    boneWorldMatrix.copyFrom(bodyBone!.getFinalMatrix()).multiplyToRef(meshWorldMatrix, boneWorldMatrix);\n    boneWorldMatrix.getTranslationToRef(directionalLight.position);\n    directionalLight.position.y -= 10;\n\n    // highlight-start\n    arcRotateCamera.target.copyFrom(directionalLight.position);\n    arcRotateCamera.target.y += 13;\n    // highlight-end\n});\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Set the target of the camera to the position of the directional light(= the position of the model).")),(0,o.kt)("h2",{id:"add-camera-to-postprocess-render-pipeline"},"Add Camera to PostProcess Render Pipeline"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/sceneBuilder.ts"',title:'"src/sceneBuilder.ts"'},'const ssrRenderingPipeline = new SSRRenderingPipeline(\n    "ssr",\n    scene,\n    // highlight-next-line\n    [mmdCamera, arcRotateCamera],\n    false,\n    Constants.TEXTURETYPE_UNSIGNED_BYTE\n);\n\n// ...\n// highlight-next-line\nconst defaultPipeline = new DefaultRenderingPipeline("default", true, scene, [mmdCamera, arcRotateCamera]);\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Add the ",(0,o.kt)("inlineCode",{parentName:"li"},"arcRotateCamera")," to the constructor of the post-process render pipeline for applying the post-process to the camera.")),(0,o.kt)("h2",{id:"camera-switching"},"Camera Switching"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/sceneBuilder.ts"',title:'"src/sceneBuilder.ts"'},"let lastClickTime = -Infinity;\ncanvas.onclick = (): void => {\n    const currentTime = performance.now();\n    if (500 < currentTime - lastClickTime) {\n        lastClickTime = currentTime;\n        return;\n    }\n\n    lastClickTime = -Infinity;\n\n    if (scene.activeCamera === mmdCamera) {\n        defaultPipeline.depthOfFieldEnabled = false;\n        scene.activeCamera = arcRotateCamera;\n    } else {\n        defaultPipeline.depthOfFieldEnabled = true;\n        scene.activeCamera = mmdCamera;\n    }\n};\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Switch the active camera when the user double-clicks the canvas.")),(0,o.kt)(r.Z,{url:i,controls:!0,width:"100%",height:"100%",mdxType:"ReactPlayer"}),(0,o.kt)("h2",{id:"full-code-at-this-point"},"Full Code at this Point"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Thank you for your efforts. This is the end of the tutorial!")),(0,o.kt)("p",null,"For detailed explanation, please check jsdoc and source code. For questions and requests, please make an issue on GitHub."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/sceneBuilder.ts"',title:'"src/sceneBuilder.ts"'},'import "babylon-mmd/esm/Loader/Optimized/bpmxLoader";\nimport "@babylonjs/core/Lights/Shadows/shadowGeneratorSceneComponent";\nimport "@babylonjs/core/Loading/loadingScreen";\nimport "@babylonjs/core/Rendering/prePassRendererSceneComponent";\nimport "@babylonjs/core/Rendering/depthRendererSceneComponent";\nimport "@babylonjs/core/Rendering/geometryBufferRendererSceneComponent";\n\nimport { ArcRotateCamera } from "@babylonjs/core/Cameras/arcRotateCamera";\nimport { Constants } from "@babylonjs/core/Engines/constants";\nimport type { Engine } from "@babylonjs/core/Engines/engine";\nimport { DirectionalLight } from "@babylonjs/core/Lights/directionalLight";\nimport { HemisphericLight } from "@babylonjs/core/Lights/hemisphericLight";\nimport { ShadowGenerator } from "@babylonjs/core/Lights/Shadows/shadowGenerator";\nimport { SceneLoader } from "@babylonjs/core/Loading/sceneLoader";\nimport { ImageProcessingConfiguration } from "@babylonjs/core/Materials/imageProcessingConfiguration";\nimport { StandardMaterial } from "@babylonjs/core/Materials/standardMaterial";\nimport { Color3, Color4 } from "@babylonjs/core/Maths/math.color";\nimport { Matrix, Vector3 } from "@babylonjs/core/Maths/math.vector";\nimport type { Mesh } from "@babylonjs/core/Meshes/mesh";\nimport { MeshBuilder } from "@babylonjs/core/Meshes/meshBuilder";\nimport { TransformNode } from "@babylonjs/core/Meshes/transformNode";\nimport { DepthOfFieldEffectBlurLevel } from "@babylonjs/core/PostProcesses/depthOfFieldEffect";\nimport { DefaultRenderingPipeline } from "@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/defaultRenderingPipeline";\nimport { SSRRenderingPipeline } from "@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/ssrRenderingPipeline";\nimport { Scene } from "@babylonjs/core/scene";\nimport type { MmdStandardMaterialBuilder } from "babylon-mmd/esm/Loader/mmdStandardMaterialBuilder";\nimport type { BpmxLoader } from "babylon-mmd/esm/Loader/Optimized/bpmxLoader";\nimport { BvmdLoader } from "babylon-mmd/esm/Loader/Optimized/bvmdLoader";\nimport { SdefInjector } from "babylon-mmd/esm/Loader/sdefInjector";\nimport { StreamAudioPlayer } from "babylon-mmd/esm/Runtime/Audio/streamAudioPlayer";\nimport { MmdCamera } from "babylon-mmd/esm/Runtime/mmdCamera";\nimport { MmdRuntime } from "babylon-mmd/esm/Runtime/mmdRuntime";\nimport { MmdPlayerControl } from "babylon-mmd/esm/Runtime/Util/mmdPlayerControl";\n\nimport type { ISceneBuilder } from "./baseRuntime";\n\nexport class SceneBuilder implements ISceneBuilder {\n    public async build(canvas: HTMLCanvasElement, engine: Engine): Promise<Scene> {\n        SdefInjector.OverrideEngineCreateEffect(engine);\n\n        const bpmxLoader = SceneLoader.GetPluginForExtension(".bpmx") as BpmxLoader;\n        bpmxLoader.loggingEnabled = true;\n        const materialBuilder = bpmxLoader.materialBuilder as MmdStandardMaterialBuilder;\n        materialBuilder.loadOutlineRenderingProperties = (): void => { /* do nothing */ };\n\n        const scene = new Scene(engine);\n        scene.clearColor = new Color4(0.95, 0.95, 0.95, 1.0);\n\n        const mmdRoot = new TransformNode("mmdRoot", scene);\n        mmdRoot.position.z -= 50;\n\n        const mmdCamera = new MmdCamera("mmdCamera", new Vector3(0, 10, 0), scene);\n        mmdCamera.maxZ = 5000;\n        mmdCamera.parent = mmdRoot;\n\n        const arcRotateCamera = new ArcRotateCamera("arcRotateCamera", 0, 0, 45, new Vector3(0, 10, 0), scene);\n        arcRotateCamera.maxZ = 5000;\n        arcRotateCamera.setPosition(new Vector3(0, 10, -45));\n        arcRotateCamera.attachControl(canvas, false);\n        arcRotateCamera.inertia = 0.8;\n        arcRotateCamera.speed = 10;\n\n        const hemisphericLight = new HemisphericLight("hemisphericLight", new Vector3(0, 1, 0), scene);\n        hemisphericLight.intensity = 0.4;\n        hemisphericLight.specular.set(0, 0, 0);\n        hemisphericLight.groundColor.set(1, 1, 1);\n\n        const directionalLight = new DirectionalLight("directionalLight", new Vector3(0.5, -1, 1), scene);\n        directionalLight.intensity = 0.8;\n        directionalLight.autoCalcShadowZBounds = false;\n        directionalLight.autoUpdateExtends = false;\n        directionalLight.shadowMaxZ = 20;\n        directionalLight.shadowMinZ = -20;\n        directionalLight.orthoTop = 18;\n        directionalLight.orthoBottom = -3;\n        directionalLight.orthoLeft = -10;\n        directionalLight.orthoRight = 10;\n        directionalLight.shadowOrthoScale = 0;\n\n        const shadowGenerator = new ShadowGenerator(1024, directionalLight, true);\n        shadowGenerator.usePercentageCloserFiltering = true;\n        shadowGenerator.forceBackFacesOnly = false;\n        shadowGenerator.bias = 0.01;\n        shadowGenerator.filteringQuality = ShadowGenerator.QUALITY_MEDIUM;\n        shadowGenerator.frustumEdgeFalloff = 0.1;\n\n        const ground = MeshBuilder.CreateGround("ground1", { width: 120, height: 120, subdivisions: 2, updatable: false }, scene);\n        const groundMaterial = ground.material = new StandardMaterial("groundMaterial", scene);\n        groundMaterial.diffuseColor = new Color3(1.02, 1.02, 1.02);\n        ground.receiveShadows = true;\n\n        // create mmd runtime\n        const mmdRuntime = new MmdRuntime();\n        mmdRuntime.loggingEnabled = true;\n        mmdRuntime.register(scene);\n\n        mmdRuntime.playAnimation();\n\n        // add audio player\n        const audioPlayer = new StreamAudioPlayer(scene);\n        audioPlayer.preservesPitch = false;\n        audioPlayer.source = "res/pizzicato_drops.mp3";\n        mmdRuntime.setAudioPlayer(audioPlayer);\n\n        // // create player control\n        new MmdPlayerControl(scene, mmdRuntime, audioPlayer);\n\n        engine.displayLoadingUI();\n\n        let loadingTexts: string[] = [];\n        const updateLoadingText = (updateIndex: number, text: string): void => {\n            loadingTexts[updateIndex] = text;\n            engine.loadingUIText = "<br/><br/><br/><br/>" + loadingTexts.join("<br/><br/>");\n        };\n\n        const promises: Promise<any>[] = [];\n\n        bpmxLoader.boundingBoxMargin = 60;\n        promises.push(SceneLoader.ImportMeshAsync(\n            undefined,\n            "res/YYB Piano dress Miku.bpmx",\n            undefined,\n            scene,\n            (event) => updateLoadingText(0, `Loading model... ${event.loaded}/${event.total} (${Math.floor(event.loaded * 100 / event.total)}%)`)\n        ).then((result) => result.meshes[0] as Mesh));\n\n        bpmxLoader.boundingBoxMargin = 0;\n        bpmxLoader.buildSkeleton = false;\n        bpmxLoader.buildMorph = false;\n        promises.push(SceneLoader.ImportMeshAsync(\n            undefined,\n            "res/\u30ac\u30e9\u30b9\u7247\u30c9\u30fc\u30e0B.bpmx",\n            undefined,\n            scene,\n            (event) => updateLoadingText(1, `Loading stage... ${event.loaded}/${event.total} (${Math.floor(event.loaded * 100 / event.total)}%)`)\n        ));\n\n        const bvmdLoader = new BvmdLoader(scene);\n        bvmdLoader.loggingEnabled = true;\n\n        promises.push(bvmdLoader.loadAsync("motion_1", "res/pizzicato_drops_yyb_piano_miku.bvmd",\n            (event) => updateLoadingText(2, `Loading motion... ${event.loaded}/${event.total} (${Math.floor(event.loaded * 100 / event.total)}%)`))\n        );\n\n        loadingTexts = new Array(promises.length).fill("");\n\n        const loadResults = await Promise.all(promises);\n        scene.onAfterRenderObservable.addOnce(() => engine.hideLoadingUI());\n\n        loadResults;\n\n        mmdRuntime.setCamera(mmdCamera);\n        mmdCamera.addAnimation(loadResults[2]);\n        mmdCamera.setAnimation("motion_1");\n\n        const modelMesh = loadResults[0] as Mesh;\n        modelMesh.parent = mmdRoot;\n        modelMesh.receiveShadows = true;\n        shadowGenerator.addShadowCaster(modelMesh);\n\n        const bodyBone = modelMesh.skeleton!.bones.find((bone) => bone.name === "\u30bb\u30f3\u30bf\u30fc");\n        const meshWorldMatrix = modelMesh.getWorldMatrix();\n        const boneWorldMatrix = new Matrix();\n        scene.onBeforeRenderObservable.add(() => {\n            boneWorldMatrix.copyFrom(bodyBone!.getFinalMatrix()).multiplyToRef(meshWorldMatrix, boneWorldMatrix);\n            boneWorldMatrix.getTranslationToRef(directionalLight.position);\n            directionalLight.position.y -= 10;\n\n            arcRotateCamera.target.copyFrom(directionalLight.position);\n            arcRotateCamera.target.y += 13;\n        });\n\n        const mmdModel = mmdRuntime.createMmdModel(modelMesh);\n        mmdModel.addAnimation(loadResults[2]);\n        mmdModel.setAnimation("motion_1");\n\n        const ssrRenderingPipeline = new SSRRenderingPipeline(\n            "ssr",\n            scene,\n            [mmdCamera, arcRotateCamera],\n            false,\n            Constants.TEXTURETYPE_UNSIGNED_BYTE\n        );\n        ssrRenderingPipeline.step = 32;\n        ssrRenderingPipeline.maxSteps = 128;\n        ssrRenderingPipeline.maxDistance = 500;\n        ssrRenderingPipeline.enableSmoothReflections = false;\n        ssrRenderingPipeline.enableAutomaticThicknessComputation = false;\n        ssrRenderingPipeline.blurDownsample = 2;\n        ssrRenderingPipeline.ssrDownsample = 2;\n        ssrRenderingPipeline.thickness = 0.1;\n        ssrRenderingPipeline.selfCollisionNumSkip = 2;\n        ssrRenderingPipeline.blurDispersionStrength = 0;\n        ssrRenderingPipeline.roughnessFactor = 0.1;\n        ssrRenderingPipeline.reflectivityThreshold = 0.9;\n        ssrRenderingPipeline.samples = 4;\n\n        const defaultPipeline = new DefaultRenderingPipeline("default", true, scene, [mmdCamera, arcRotateCamera]);\n        defaultPipeline.samples = 4;\n        defaultPipeline.bloomEnabled = true;\n        defaultPipeline.chromaticAberrationEnabled = true;\n        defaultPipeline.chromaticAberration.aberrationAmount = 1;\n        defaultPipeline.depthOfFieldEnabled = true;\n        defaultPipeline.depthOfFieldBlurLevel = DepthOfFieldEffectBlurLevel.High;\n        defaultPipeline.fxaaEnabled = true;\n        defaultPipeline.imageProcessingEnabled = true;\n        defaultPipeline.imageProcessing.toneMappingEnabled = true;\n        defaultPipeline.imageProcessing.toneMappingType = ImageProcessingConfiguration.TONEMAPPING_ACES;\n        defaultPipeline.imageProcessing.vignetteWeight = 0.5;\n        defaultPipeline.imageProcessing.vignetteStretch = 0.5;\n        defaultPipeline.imageProcessing.vignetteColor = new Color4(0, 0, 0, 0);\n        defaultPipeline.imageProcessing.vignetteEnabled = true;\n\n        defaultPipeline.depthOfField.fStop = 0.05;\n        defaultPipeline.depthOfField.focalLength = 20;\n\n        const headBone = modelMesh.skeleton!.bones.find((bone) => bone.name === "\u982d");\n\n        const rotationMatrix = new Matrix();\n        const cameraNormal = new Vector3();\n        const cameraEyePosition = new Vector3();\n        const headRelativePosition = new Vector3();\n\n        scene.onBeforeRenderObservable.add(() => {\n            const cameraRotation = mmdCamera.rotation;\n            Matrix.RotationYawPitchRollToRef(-cameraRotation.y, -cameraRotation.x, -cameraRotation.z, rotationMatrix);\n\n            Vector3.TransformNormalFromFloatsToRef(0, 0, 1, rotationMatrix, cameraNormal);\n\n            mmdCamera.position.addToRef(\n                Vector3.TransformCoordinatesFromFloatsToRef(0, 0, mmdCamera.distance, rotationMatrix, cameraEyePosition),\n                cameraEyePosition\n            );\n\n            headBone!.getFinalMatrix().getTranslationToRef(headRelativePosition)\n                .subtractToRef(cameraEyePosition, headRelativePosition);\n\n            defaultPipeline.depthOfField.focusDistance = (Vector3.Dot(headRelativePosition, cameraNormal) / Vector3.Dot(cameraNormal, cameraNormal)) * 1000;\n        });\n\n        let lastClickTime = -Infinity;\n        canvas.onclick = (): void => {\n            const currentTime = performance.now();\n            if (500 < currentTime - lastClickTime) {\n                lastClickTime = currentTime;\n                return;\n            }\n\n            lastClickTime = -Infinity;\n\n            if (scene.activeCamera === mmdCamera) {\n                defaultPipeline.depthOfFieldEnabled = false;\n                scene.activeCamera = arcRotateCamera;\n            } else {\n                defaultPipeline.depthOfFieldEnabled = true;\n                scene.activeCamera = mmdCamera;\n            }\n        };\n\n        return scene;\n    }\n}\n')))}h.isMDXComponent=!0}}]);