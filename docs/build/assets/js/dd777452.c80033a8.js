"use strict";(self.webpackChunkbabylon_mmd_docs=self.webpackChunkbabylon_mmd_docs||[]).push([[653],{7630:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>m,default:()=>h,frontMatter:()=>d,metadata:()=>l,toc:()=>c});var o=t(7462),a=(t(7294),t(3905)),i=t(2004);const r=t.p+"assets/medias/2023-07-29 18-53-00-33748f2b95d7a6706cb324e1793504ad.mp4",d={},m="Load BVMD Animation",l={unversionedId:"deep-usage/load-bvmd-animation/index",id:"deep-usage/load-bvmd-animation/index",title:"Load BVMD Animation",description:"Learn how to load and play animations in BVMD format.",source:"@site/docs/1-deep-usage/5-load-bvmd-animation/index.mdx",sourceDirName:"1-deep-usage/5-load-bvmd-animation",slug:"/deep-usage/load-bvmd-animation/",permalink:"/babylon-mmd/docs/deep-usage/load-bvmd-animation/",draft:!1,editUrl:"https://github.com/noname0310/babylon-mmd/tree/main/docs/babylon-mmd-docs/docs/1-deep-usage/5-load-bvmd-animation/index.mdx",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Convert VMD animation into BVMD",permalink:"/babylon-mmd/docs/deep-usage/convert-vmd-animation-into-bvmd/"},next:{title:"Audio And Player Controls",permalink:"/babylon-mmd/docs/deep-usage/audio-and-player/"}},s={},c=[{value:"Creae MMD Runtime",id:"creae-mmd-runtime",level:2},{value:"Load BVMD Animation",id:"load-bvmd-animation-1",level:2},{value:"Change Animation Center",id:"change-animation-center",level:2},{value:"Make Directional Light Follow Model",id:"make-directional-light-follow-model",level:2},{value:"Full Code at this Point",id:"full-code-at-this-point",level:2}],p={toc:c},u="wrapper";function h(e){let{components:n,...t}=e;return(0,a.kt)(u,(0,o.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"load-bvmd-animation"},"Load BVMD Animation"),(0,a.kt)("p",null,"Learn how to load and play animations in BVMD format."),(0,a.kt)("h2",{id:"creae-mmd-runtime"},"Creae MMD Runtime"),(0,a.kt)("p",null,"MMD has its proprietary animation system, so we provides a runtime to reproduce it. We will create an MMD Runtime and make the camera and mesh controlled by the runtime."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/sceneBuilder.ts"',title:'"src/sceneBuilder.ts"'},"const mmdRuntime = new MmdRuntime();\nmmdRuntime.loggingEnabled = true;\nmmdRuntime.register(scene);\n\nmmdRuntime.playAnimation();\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"mmdRuntime.register(scene)")," - Register the runtime to the scene update loop. This is required to runtime to work."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"mmdRuntime.loggingEnabled = true")," - Enable logging. You can see some useful information (e.g. Animation binding failed bones) in the console."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"mmdRuntime.playAnimation()")," - Start playing the animation.")),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"It's possible to play animations even if no asset is loaded. In this case, the assets that are loaded later are automatically synchronized.")),(0,a.kt)("p",null,"Now let's add objects that will be controlled by runtime."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/sceneBuilder.ts"',title:'"src/sceneBuilder.ts"'},"mmdRuntime.setCamera(mmdCamera);\nconst mmdModel = mmdRuntime.createMmdModel(modelMesh);\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"mmdRuntime.setCamera(camera)")," - Set the camera to be controlled by the runtime."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"mmdRuntime.createMmdModel(mmdMesh)")," - Create an MMD model from the mesh. ",(0,a.kt)("inlineCode",{parentName:"li"},"MmdModel")," is a kind of controller that abstracts and controls Mesh from the perspective of MMD.")),(0,a.kt)("h2",{id:"load-bvmd-animation-1"},"Load BVMD Animation"),(0,a.kt)("p",null,"For load BVMD animation, we use the ",(0,a.kt)("inlineCode",{parentName:"p"},"BvmdLoader"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/sceneBuilder.ts"',title:'"src/sceneBuilder.ts"'},'const bvmdLoader = new BvmdLoader(scene);\nbvmdLoader.loggingEnabled = true;\n\npromises.push(bvmdLoader.loadAsync("motion_1", "res/pizzicato_drops_yyb_piano_miku.bvmd",\n    (event) => updateLoadingText(2, `Loading motion... ${event.loaded}/${event.total} (${Math.floor(event.loaded * 100 / event.total)}%)`))\n);\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"bvmdLoader.loadAsync(name, fileOrUrl, onProgress)")," - Load BVMD file. ",(0,a.kt)("inlineCode",{parentName:"li"},"name")," is the name of the animation. ",(0,a.kt)("inlineCode",{parentName:"li"},"onProgress")," is a callback function that is called during loading.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/sceneBuilder.ts"',title:'"src/sceneBuilder.ts"'},'mmdCamera.addAnimation(loadResults[2]);\nmmdCamera.setAnimation("motion_1");\n\nmmdModel.addAnimation(loadResults[2]);\nmmdModel.setAnimation("motion_1");\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Both ",(0,a.kt)("inlineCode",{parentName:"li"},"MmdCamera")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"MmdModel")," are designed to store multiple animations. Therefore, you must set the animation to use after adding it.")),(0,a.kt)("h2",{id:"change-animation-center"},"Change Animation Center"),(0,a.kt)("p",null,"The motion that we use tends to move backwards as we go towards the end of the music. So you have to move the model and camera forward to keep them in the plane."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/sceneBuilder.ts"',title:'"src/sceneBuilder.ts"'},'const mmdRoot = new TransformNode("mmdRoot", scene);\nmmdRoot.position.z -= 50;\n\n// ...\n\nmmdCamera.parent = mmdRoot;\n\n// ...\n\nmodelMesh.parent = mmdRoot;\n')),(0,a.kt)("h2",{id:"make-directional-light-follow-model"},"Make Directional Light Follow Model"),(0,a.kt)("p",null,"Our shadow frustum is fitted to the model. So we need to move the directional light to follow the model. to see the shadow properly."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/sceneBuilder.ts"',title:'"src/sceneBuilder.ts"'},'const bodyBone = modelMesh.skeleton!.bones.find((bone) => bone.name === "\u30bb\u30f3\u30bf\u30fc");\nconst meshWorldMatrix = modelMesh.getWorldMatrix();\nconst boneWorldMatrix = new Matrix();\nscene.onBeforeRenderObservable.add(() => {\n    boneWorldMatrix.copyFrom(bodyBone!.getFinalMatrix()).multiplyToRef(meshWorldMatrix, boneWorldMatrix);\n    boneWorldMatrix.getTranslationToRef(directionalLight.position);\n    directionalLight.position.y -= 10;\n});\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},'modelMesh.skeleton!.bones.find((bone) => bone.name === "\u30bb\u30f3\u30bf\u30fc")'),' - Get the bone named "\u30bb\u30f3\u30bf\u30fc" from the skeleton of the model. This bone is the center of the model.'),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"modelMesh.getWorldMatrix()")," - Get the world matrix of the model. Access after the Physics ensures that the matrix is up to date.")),(0,a.kt)("admonition",{type:"danger"},(0,a.kt)("p",{parentName:"admonition"},"For skeleton, which is being manipulated by ",(0,a.kt)("inlineCode",{parentName:"p"},"MmdRuntime"),", the only way to get the world position value is to use ",(0,a.kt)("inlineCode",{parentName:"p"},"getWorldMatrix()")," because the Matrix update method is overridden by ",(0,a.kt)("inlineCode",{parentName:"p"},"MmdRuntime"),". (e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"bone.getAbsolutePosition()")," doesn't work properly)"),(0,a.kt)("p",{parentName:"admonition"},"Because MMD uses its own matrix update policy, this flaw is inevitable.")),(0,a.kt)("h2",{id:"full-code-at-this-point"},"Full Code at this Point"),(0,a.kt)("p",null,"Here's the code up to this point:"),(0,a.kt)("details",null," ",(0,a.kt)("summary",null,"src/sceneBuilder.ts"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'iimport "babylon-mmd/esm/Loader/Optimized/bpmxLoader";\nimport "@babylonjs/core/Lights/Shadows/shadowGeneratorSceneComponent";\nimport "@babylonjs/core/Loading/loadingScreen";\n\nimport type { Engine } from "@babylonjs/core/Engines/engine";\nimport { DirectionalLight } from "@babylonjs/core/Lights/directionalLight";\nimport { HemisphericLight } from "@babylonjs/core/Lights/hemisphericLight";\nimport { ShadowGenerator } from "@babylonjs/core/Lights/Shadows/shadowGenerator";\nimport { SceneLoader } from "@babylonjs/core/Loading/sceneLoader";\nimport { StandardMaterial } from "@babylonjs/core/Materials/standardMaterial";\nimport { Color3, Color4 } from "@babylonjs/core/Maths/math.color";\nimport { Matrix, Vector3 } from "@babylonjs/core/Maths/math.vector";\nimport type { Mesh } from "@babylonjs/core/Meshes/mesh";\nimport { MeshBuilder } from "@babylonjs/core/Meshes/meshBuilder";\nimport { TransformNode } from "@babylonjs/core/Meshes/transformNode";\nimport { Scene } from "@babylonjs/core/scene";\nimport type { MmdStandardMaterialBuilder } from "babylon-mmd/esm/Loader/mmdStandardMaterialBuilder";\nimport type { BpmxLoader } from "babylon-mmd/esm/Loader/Optimized/bpmxLoader";\nimport { BvmdLoader } from "babylon-mmd/esm/Loader/Optimized/bvmdLoader";\nimport { MmdCamera } from "babylon-mmd/esm/Runtime/mmdCamera";\nimport { MmdRuntime } from "babylon-mmd/esm/Runtime/mmdRuntime";\n\nimport type { ISceneBuilder } from "./baseRuntime";\n\nexport class SceneBuilder implements ISceneBuilder {\n    public async build(_canvas: HTMLCanvasElement, engine: Engine): Promise<Scene> {\n        const bpmxLoader = SceneLoader.GetPluginForExtension(".bpmx") as BpmxLoader;\n        bpmxLoader.loggingEnabled = true;\n        const materialBuilder = bpmxLoader.materialBuilder as MmdStandardMaterialBuilder;\n        materialBuilder.loadOutlineRenderingProperties = (): void => { /* do nothing */ };\n\n        const scene = new Scene(engine);\n        scene.clearColor = new Color4(0.95, 0.95, 0.95, 1.0);\n\n        const mmdRoot = new TransformNode("mmdRoot", scene);\n        mmdRoot.position.z -= 50;\n\n        const mmdCamera = new MmdCamera("mmdCamera", new Vector3(0, 10, 0), scene);\n        mmdCamera.maxZ = 5000;\n        mmdCamera.parent = mmdRoot;\n\n        const hemisphericLight = new HemisphericLight("hemisphericLight", new Vector3(0, 1, 0), scene);\n        hemisphericLight.intensity = 0.4;\n        hemisphericLight.specular.set(0, 0, 0);\n        hemisphericLight.groundColor.set(1, 1, 1);\n\n        const directionalLight = new DirectionalLight("directionalLight", new Vector3(0.5, -1, 1), scene);\n        directionalLight.intensity = 0.8;\n        directionalLight.autoCalcShadowZBounds = false;\n        directionalLight.autoUpdateExtends = false;\n        directionalLight.shadowMaxZ = 20;\n        directionalLight.shadowMinZ = -20;\n        directionalLight.orthoTop = 18;\n        directionalLight.orthoBottom = -3;\n        directionalLight.orthoLeft = -10;\n        directionalLight.orthoRight = 10;\n        directionalLight.shadowOrthoScale = 0;\n\n        const shadowGenerator = new ShadowGenerator(1024, directionalLight, true);\n        shadowGenerator.usePercentageCloserFiltering = true;\n        shadowGenerator.forceBackFacesOnly = false;\n        shadowGenerator.bias = 0.01;\n        shadowGenerator.filteringQuality = ShadowGenerator.QUALITY_MEDIUM;\n        shadowGenerator.frustumEdgeFalloff = 0.1;\n\n        const ground = MeshBuilder.CreateGround("ground1", { width: 120, height: 120, subdivisions: 2, updatable: false }, scene);\n        const groundMaterial = ground.material = new StandardMaterial("groundMaterial", scene);\n        groundMaterial.diffuseColor = new Color3(1.02, 1.02, 1.02);\n        ground.receiveShadows = true;\n\n        // create mmd runtime\n        const mmdRuntime = new MmdRuntime();\n        mmdRuntime.loggingEnabled = true;\n        mmdRuntime.register(scene);\n\n        mmdRuntime.playAnimation();\n\n        engine.displayLoadingUI();\n\n        let loadingTexts: string[] = [];\n        const updateLoadingText = (updateIndex: number, text: string): void => {\n            loadingTexts[updateIndex] = text;\n            engine.loadingUIText = "<br/><br/><br/><br/>" + loadingTexts.join("<br/><br/>");\n        };\n\n        const promises: Promise<any>[] = [];\n\n        bpmxLoader.boundingBoxMargin = 60;\n        promises.push(SceneLoader.ImportMeshAsync(\n            undefined,\n            "res/YYB Piano dress Miku.bpmx",\n            undefined,\n            scene,\n            (event) => updateLoadingText(0, `Loading model... ${event.loaded}/${event.total} (${Math.floor(event.loaded * 100 / event.total)}%)`)\n        ).then((result) => result.meshes[0] as Mesh));\n\n        bpmxLoader.boundingBoxMargin = 0;\n        bpmxLoader.buildSkeleton = false;\n        bpmxLoader.buildMorph = false;\n        promises.push(SceneLoader.ImportMeshAsync(\n            undefined,\n            "res/\u30ac\u30e9\u30b9\u7247\u30c9\u30fc\u30e0B.bpmx",\n            undefined,\n            scene,\n            (event) => updateLoadingText(1, `Loading stage... ${event.loaded}/${event.total} (${Math.floor(event.loaded * 100 / event.total)}%)`)\n        ));\n\n        const bvmdLoader = new BvmdLoader(scene);\n        bvmdLoader.loggingEnabled = true;\n\n        promises.push(bvmdLoader.loadAsync("motion_1", "res/pizzicato_drops_yyb_piano_miku.bvmd",\n            (event) => updateLoadingText(2, `Loading motion... ${event.loaded}/${event.total} (${Math.floor(event.loaded * 100 / event.total)}%)`))\n        );\n\n        loadingTexts = new Array(promises.length).fill("");\n\n        const loadResults = await Promise.all(promises);\n        scene.onAfterRenderObservable.addOnce(() => engine.hideLoadingUI());\n\n        loadResults;\n\n        mmdRuntime.setCamera(mmdCamera);\n        mmdCamera.addAnimation(loadResults[2]);\n        mmdCamera.setAnimation("motion_1");\n\n        const modelMesh = loadResults[0] as Mesh;\n        modelMesh.parent = mmdRoot;\n        modelMesh.receiveShadows = true;\n        shadowGenerator.addShadowCaster(modelMesh);\n\n        const bodyBone = modelMesh.skeleton!.bones.find((bone) => bone.name === "\u30bb\u30f3\u30bf\u30fc");\n        const meshWorldMatrix = modelMesh.getWorldMatrix();\n        const boneWorldMatrix = new Matrix();\n        scene.onBeforeRenderObservable.add(() => {\n            boneWorldMatrix.copyFrom(bodyBone!.getFinalMatrix()).multiplyToRef(meshWorldMatrix, boneWorldMatrix);\n            boneWorldMatrix.getTranslationToRef(directionalLight.position);\n            directionalLight.position.y -= 10;\n        });\n\n        const mmdModel = mmdRuntime.createMmdModel(modelMesh);\n        mmdModel.addAnimation(loadResults[2]);\n        mmdModel.setAnimation("motion_1");\n\n        return scene;\n    }\n}\n\n'))),(0,a.kt)(i.Z,{url:r,controls:!0,width:"100%",height:"100%",mdxType:"ReactPlayer"}))}h.isMDXComponent=!0}}]);