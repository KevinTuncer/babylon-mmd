"use strict";(self.webpackChunkbabylon_mmd_docs=self.webpackChunkbabylon_mmd_docs||[]).push([[810],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=d(a),p=r,h=m["".concat(l,".").concat(p)]||m[p]||u[p]||i;return a?n.createElement(h,o(o({ref:t},c),{},{components:a})):n.createElement(h,o({ref:t},c))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:r,o[1]=s;for(var d=2;d<i;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},2963:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var n=a(7462),r=(a(7294),a(3905));const i={},o="Troubleshooting Shading Artifacts",s={unversionedId:"quick-start/troubleshooting-shading-artifacts/index",id:"quick-start/troubleshooting-shading-artifacts/index",title:"Troubleshooting Shading Artifacts",description:"This section addresses common shading issues.",source:"@site/docs/quick-start/5-troubleshooting-shading-artifacts/index.md",sourceDirName:"quick-start/5-troubleshooting-shading-artifacts",slug:"/quick-start/troubleshooting-shading-artifacts/",permalink:"/babylon-mmd/build/docs/quick-start/troubleshooting-shading-artifacts/",draft:!1,editUrl:"https://github.com/noname0310/babylon-mmd/tree/main/docs/babylon-mmd-docs/docs/quick-start/5-troubleshooting-shading-artifacts/index.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Use Physics Engine",permalink:"/babylon-mmd/build/docs/quick-start/physics/"},next:{title:"Deep Usage",permalink:"/babylon-mmd/build/docs/category/deep-usage"}},l={},d=[{value:"Shadow Artifacts at Joints",id:"shadow-artifacts-at-joints",level:2},{value:"Transparent Artifacts",id:"transparent-artifacts",level:2},{value:"Outline Artifacts",id:"outline-artifacts",level:2},{value:"Full code applied up to here",id:"full-code-applied-up-to-here",level:2}],c={toc:d},m="wrapper";function u(e){let{components:t,...i}=e;return(0,r.kt)(m,(0,n.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"troubleshooting-shading-artifacts"},"Troubleshooting Shading Artifacts"),(0,r.kt)("p",null,"This section addresses common shading issues."),(0,r.kt)("h2",{id:"shadow-artifacts-at-joints"},"Shadow Artifacts at Joints"),(0,r.kt)("p",null,"The MMD model use Spherical Deformation which is not supported in shadow map. So, the shadow at the joint will be broken."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Knee",src:a(3897).Z,width:"378",height:"215"})),(0,r.kt)("p",null,"To resolve this issue, you can force all shaders to support SDEF or disable the SDEF feature when loading pmx."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Note that with SDEF, you get the same results as MMD, but use more performance")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/sceneBuilder.ts"',title:'"src/sceneBuilder.ts"'},"SdefInjector.OverrideEngineCreateEffect(engine); // Force all shaders to support SDEF\n// this method must be called before creating the scene\n")),(0,r.kt)("p",null,"or"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/sceneBuilder.ts"',title:'"src/sceneBuilder.ts"'},'const pmxLoader = SceneLoader.GetPluginForExtension(".pmx") as PmxLoader;\npmxLoader.useSdef = false; // Disable SDEF\n')),(0,r.kt)("p",null,"Result:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Knee Solved",src:a(2374).Z,width:"328",height:"195"})),(0,r.kt)("h2",{id:"transparent-artifacts"},"Transparent Artifacts"),(0,r.kt)("p",null,"This is a problem that was not shown in this tutorial, but for models that use a lot of alpha textures, the high probability of shading will be weird."),(0,r.kt)("p",null,"Although an algorithm is implemented to determine whether to render materials as alpha blending, it is impossible to achieve perfect results because Babylon.js and MMD's alpha blending methods are different."),(0,r.kt)("p",null,"So to solve this problem, you need to hardcode whether the material is alpha blended or not. Like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/sceneBuilder.ts"',title:'"src/sceneBuilder.ts"'},'const pmxLoader = SceneLoader.GetPluginForExtension(".pmx") as PmxLoader;\npmxLoader.useSdef = false;\nconst materialBuilder = pmxLoader.materialBuilder as MmdStandardMaterialBuilder;\nmaterialBuilder.useAlphaEvaluation = false;\nconst alphaBlendMaterials = ["face02", "Facial02", "HL", "Hairshadow", "q302"];\nconst alphaTestMaterials = ["q301"];\nmaterialBuilder.afterBuildSingleMaterial = (material): void => {\n    if (!alphaBlendMaterials.includes(material.name) && !alphaTestMaterials.includes(material.name)) return;\n    material.transparencyMode = alphaBlendMaterials.includes(material.name)\n        ? Material.MATERIAL_ALPHABLEND\n        : Material.MATERIAL_ALPHATEST;\n    material.useAlphaFromDiffuseTexture = true;\n    material.diffuseTexture!.hasAlpha = true;\n};\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"useAlphaEvaluation")," - If false, all material loaded as opaque."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"afterBuildSingleMaterial")," - This callback is called after the material is created. You can use this to preprocess the material.")),(0,r.kt)("h2",{id:"outline-artifacts"},"Outline Artifacts"),(0,r.kt)("p",null,"Outline rendering often causes problems with materials that are alpha-blended."),(0,r.kt)("p",null,"In this case, you should consider turning off outline rendering partially or disabling it in loaders."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/sceneBuilder.ts"',title:'"src/sceneBuilder.ts"'},'const pmxLoader = SceneLoader.GetPluginForExtension(".pmx") as PmxLoader;\nconst materialBuilder = pmxLoader.materialBuilder as MmdStandardMaterialBuilder;\n\nmaterialBuilder.loadOutlineRenderingProperties = () => { /* do nothing */ };\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"loadOutlineRenderingProperties")," - This callback is called when loading the outline rendering properties. You can override this to customize the outline rendering properties.")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Deactivating at load time is more efficient than deactivating after loading. Because once loaded, the shader gets compiled"),(0,r.kt)("p",{parentName:"admonition"},"So if you want to make any changes to the loaded asset, check the loader option first")),(0,r.kt)("h2",{id:"full-code-applied-up-to-here"},"Full code applied up to here"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="src/sceneBuilder.ts"',title:'"src/sceneBuilder.ts"'},'import type { Engine, Mesh } from "@babylonjs/core";\nimport { DirectionalLight, HavokPlugin, HemisphericLight, Material, MeshBuilder, Scene, SceneLoader, ShadowGenerator, Vector3 } from "@babylonjs/core";\nimport HavokPhysics from "@babylonjs/havok";\nimport type { MmdStandardMaterialBuilder } from "babylon-mmd";\nimport { MmdCamera, MmdPhysics, MmdPlayerControl, MmdRuntime, PmxLoader, SdefInjector, StreamAudioPlayer, VmdLoader } from "babylon-mmd";\n\nimport type { ISceneBuilder } from "./baseRuntime";\n\nexport class SceneBuilder implements ISceneBuilder {\n    public async build(_canvas: HTMLCanvasElement, engine: Engine): Promise<Scene> {\n        SdefInjector.OverrideEngineCreateEffect(engine);\n        SceneLoader.RegisterPlugin(new PmxLoader());\n\n        // fix material alpha mode\n        const pmxLoader = SceneLoader.GetPluginForExtension(".pmx") as PmxLoader;\n        pmxLoader.useSdef = false;\n        const materialBuilder = pmxLoader.materialBuilder as MmdStandardMaterialBuilder;\n        materialBuilder.useAlphaEvaluation = false;\n        const alphaBlendMaterials = ["face02", "Facial02", "HL", "Hairshadow", "q302"];\n        const alphaTestMaterials = ["q301"];\n        materialBuilder.afterBuildSingleMaterial = (material): void => {\n            if (!alphaBlendMaterials.includes(material.name) && !alphaTestMaterials.includes(material.name)) return;\n            material.transparencyMode = alphaBlendMaterials.includes(material.name)\n                ? Material.MATERIAL_ALPHABLEND\n                : Material.MATERIAL_ALPHATEST;\n            material.useAlphaFromDiffuseTexture = true;\n            material.diffuseTexture!.hasAlpha = true;\n        };\n\n        const scene = new Scene(engine);\n\n        const camera = new MmdCamera("mmdCamera", new Vector3(0, 10, 0), scene);\n\n        const hemisphericLight = new HemisphericLight("HemisphericLight", new Vector3(0, 1, 0), scene);\n        hemisphericLight.intensity = 0.4;\n        hemisphericLight.specular.set(0, 0, 0);\n        hemisphericLight.groundColor.set(1, 1, 1);\n\n        const directionalLight = new DirectionalLight("DirectionalLight", new Vector3(0.5, -1, 1), scene);\n        directionalLight.intensity = 0.8;\n        directionalLight.shadowMaxZ = 20;\n        directionalLight.shadowMinZ = -15;\n\n        const shadowGenerator = new ShadowGenerator(2048, directionalLight, true, camera);\n        shadowGenerator.bias = 0.01;\n\n        const ground = MeshBuilder.CreateGround("ground1", { width: 60, height: 60, subdivisions: 2, updatable: false }, scene);\n        ground.receiveShadows = true;\n        shadowGenerator.addShadowCaster(ground);\n\n        // load mmd model\n        const mmdMesh = await SceneLoader.ImportMeshAsync("", "res/YYB Hatsune Miku_10th/YYB Hatsune Miku_10th_v1.02.pmx", undefined, scene)\n            .then((result) => result.meshes[0] as Mesh);\n        mmdMesh.receiveShadows = true;\n        shadowGenerator.addShadowCaster(mmdMesh);\n\n        // // enable physics\n        scene.enablePhysics(new Vector3(0, -9.8, 0), new HavokPlugin(true, await HavokPhysics()));\n\n        // create mmd runtime\n        const mmdRuntime = new MmdRuntime(new MmdPhysics(scene));\n        mmdRuntime.register(scene);\n\n        mmdRuntime.setCamera(camera);\n        const mmdModel = mmdRuntime.createMmdModel(mmdMesh);\n\n        // load animation\n        const vmdLoader = new VmdLoader(scene);\n        const modelMotion = await vmdLoader.loadAsync("model_motion_1", [\n            "res/\u30e1\u30e9\u30f3\u30b3\u30ea\u30fb\u30ca\u30a4\u30c8/\u30e1\u30e9\u30f3\u30b3\u30ea\u30fb\u30ca\u30a4\u30c8.vmd",\n            "res/\u30e1\u30e9\u30f3\u30b3\u30ea\u30fb\u30ca\u30a4\u30c8/\u30e1\u30e9\u30f3\u30b3\u30ea\u30fb\u30ca\u30a4\u30c8_\u8868\u60c5\u30e2\u30fc\u30b7\u30e7\u30f3.vmd",\n            "res/\u30e1\u30e9\u30f3\u30b3\u30ea\u30fb\u30ca\u30a4\u30c8/\u30e1\u30e9\u30f3\u30b3\u30ea\u30fb\u30ca\u30a4\u30c8_\u30ea\u30c3\u30d7\u30e2\u30fc\u30b7\u30e7\u30f3.vmd"\n        ]);\n        const cameraMotion = await vmdLoader.loadAsync("camera_motion_1",\n            "res/\u30e1\u30e9\u30f3\u30b3\u30ea\u30fb\u30ca\u30a4\u30c8/\u30e1\u30e9\u30f3\u30b3\u30ea\u30fb\u30ca\u30a4\u30c8_\u30ab\u30e1\u30e9.vmd"\n        );\n\n        mmdModel.addAnimation(modelMotion);\n        mmdModel.setAnimation("model_motion_1");\n\n        camera.addAnimation(cameraMotion);\n        camera.setAnimation("camera_motion_1");\n\n        // add audio player\n        const audioPlayer = new StreamAudioPlayer(scene);\n        audioPlayer.source = "res/higma - \u30e1\u30e9\u30f3\u30b3\u30ea\u30ca\u30a4\u30c8 melancholy night feat.\u521d\u97f3\u30df\u30af.mp3";\n        mmdRuntime.setAudioPlayer(audioPlayer);\n\n        mmdRuntime.playAnimation();\n        new MmdPlayerControl(scene, mmdRuntime, audioPlayer);\n\n        return scene;\n    }\n}\n')))}u.isMDXComponent=!0},2374:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/image-1-edcf727bb86e1faf59843035f8a711c1.png"},3897:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/image-00a842447f878f7007209f02c45815ab.png"}}]);